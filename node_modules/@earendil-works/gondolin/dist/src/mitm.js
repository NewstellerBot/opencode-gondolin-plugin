"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultMitmCertDir = getDefaultMitmCertDir;
exports.resolveMitmCertDir = resolveMitmCertDir;
exports.loadOrCreateMitmCa = loadOrCreateMitmCa;
exports.loadOrCreateMitmCaSync = loadOrCreateMitmCaSync;
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_fs_1 = __importDefault(require("node:fs"));
const promises_1 = __importDefault(require("node:fs/promises"));
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const node_forge_1 = __importDefault(require("node-forge"));
function getDefaultMitmCertDir() {
    const cacheBase = process.env.XDG_CACHE_HOME ?? node_path_1.default.join(node_os_1.default.homedir(), ".cache");
    return node_path_1.default.join(cacheBase, "gondolin", "ssl");
}
function resolveMitmCertDir(mitmCertDir) {
    return mitmCertDir ?? getDefaultMitmCertDir();
}
async function loadOrCreateMitmCa(mitmDir) {
    await promises_1.default.mkdir(mitmDir, { recursive: true });
    const caKeyPath = node_path_1.default.join(mitmDir, "ca.key");
    const caCertPath = node_path_1.default.join(mitmDir, "ca.crt");
    try {
        const [keyPem, certPem] = await Promise.all([
            promises_1.default.readFile(caKeyPath, "utf8"),
            promises_1.default.readFile(caCertPath, "utf8"),
        ]);
        return {
            key: node_forge_1.default.pki.privateKeyFromPem(keyPem),
            cert: node_forge_1.default.pki.certificateFromPem(certPem),
            keyPem,
            certPem,
        };
    }
    catch {
        const generated = generateMitmCa();
        await Promise.all([
            promises_1.default.writeFile(caKeyPath, generated.keyPem),
            promises_1.default.writeFile(caCertPath, generated.certPem),
        ]);
        return generated;
    }
}
function loadOrCreateMitmCaSync(mitmDir) {
    node_fs_1.default.mkdirSync(mitmDir, { recursive: true });
    const caKeyPath = node_path_1.default.join(mitmDir, "ca.key");
    const caCertPath = node_path_1.default.join(mitmDir, "ca.crt");
    try {
        const keyPem = node_fs_1.default.readFileSync(caKeyPath, "utf8");
        const certPem = node_fs_1.default.readFileSync(caCertPath, "utf8");
        return {
            key: node_forge_1.default.pki.privateKeyFromPem(keyPem),
            cert: node_forge_1.default.pki.certificateFromPem(certPem),
            keyPem,
            certPem,
        };
    }
    catch {
        const generated = generateMitmCa();
        node_fs_1.default.writeFileSync(caKeyPath, generated.keyPem);
        node_fs_1.default.writeFileSync(caCertPath, generated.certPem);
        return generated;
    }
}
function generateMitmCa() {
    const keys = node_forge_1.default.pki.rsa.generateKeyPair(2048);
    const cert = node_forge_1.default.pki.createCertificate();
    cert.publicKey = keys.publicKey;
    cert.serialNumber = node_crypto_1.default.randomBytes(16).toString("hex");
    const now = new Date(Date.now() - 5 * 60 * 1000);
    cert.validity.notBefore = now;
    cert.validity.notAfter = new Date(now);
    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + 3650);
    const attrs = [{ name: "commonName", value: "gondolin-mitm-ca" }];
    cert.setSubject(attrs);
    cert.setIssuer(attrs);
    cert.setExtensions([
        { name: "basicConstraints", cA: true, critical: true },
        {
            name: "keyUsage",
            keyCertSign: true,
            cRLSign: true,
            critical: true,
        },
    ]);
    cert.sign(keys.privateKey, node_forge_1.default.md.sha256.create());
    const keyPem = node_forge_1.default.pki.privateKeyToPem(keys.privateKey);
    const certPem = node_forge_1.default.pki.certificateToPem(cert);
    return {
        key: keys.privateKey,
        cert,
        keyPem,
        certPem,
    };
}
//# sourceMappingURL=mitm.js.map