import { PassThrough, Readable } from "stream";
/**
 * Output chunk from a streaming exec, with stream label.
 */
export type OutputChunk = {
    stream: "stdout" | "stderr";
    data: Buffer;
    text: string;
};
/**
 * Result of a completed exec command.
 */
export declare class ExecResult {
    readonly id: number;
    readonly exitCode: number;
    readonly signal?: number;
    private readonly _stdout;
    private readonly _stderr;
    private readonly _encoding;
    constructor(id: number, exitCode: number, stdout: Buffer, stderr: Buffer, signal?: number, encoding?: BufferEncoding);
    /** stdout as string */
    get stdout(): string;
    /** stderr as string */
    get stderr(): string;
    /** stdout as Buffer (for binary data) */
    get stdoutBuffer(): Buffer;
    /** stderr as Buffer (for binary data) */
    get stderrBuffer(): Buffer;
    /** Parse stdout as JSON */
    json<T = unknown>(): T;
    /** Split stdout into lines */
    lines(): string[];
    /** Check if the command succeeded (exit code 0) */
    get ok(): boolean;
    toString(): string;
}
/**
 * Options for exec/execStream.
 */
export type ExecOptions = {
    /** Additional arguments (when command is a string) */
    argv?: string[];
    /** Environment variables */
    env?: string[] | Record<string, string>;
    /** Working directory */
    cwd?: string;
    /**
     * Stdin input. Can be:
     * - true: enable stdin for manual writing via write()/end()
     * - string/Buffer: send this data as stdin
     * - Readable/AsyncIterable: pipe this stream to stdin
     */
    stdin?: boolean | string | Buffer | Readable | AsyncIterable<Buffer>;
    /** Enable PTY mode for interactive commands */
    pty?: boolean;
    /** Encoding for string output (default: utf-8) */
    encoding?: BufferEncoding;
    /** Abort signal to cancel the command */
    signal?: AbortSignal;
};
/**
 * Internal session state for tracking an exec command.
 */
export type ExecSession = {
    id: number;
    stdout: PassThrough;
    stderr: PassThrough;
    stdoutChunks: Buffer[];
    stderrChunks: Buffer[];
    resolve: (result: ExecResult) => void;
    reject: (error: Error) => void;
    resultPromise: Promise<ExecResult>;
    stdinEnabled: boolean;
    encoding: BufferEncoding;
    signal?: AbortSignal;
    signalListener?: () => void;
    iterating: boolean;
    requestReady: boolean;
    pendingStdin: Array<{
        type: "data";
        data: Buffer | string;
    } | {
        type: "eof";
    }>;
    pendingResize: {
        rows: number;
        cols: number;
    } | null;
};
/**
 * Callbacks for ExecProcess to communicate with VM.
 */
export type ExecProcessCallbacks = {
    sendStdin: (id: number, data: Buffer | string) => void;
    sendStdinEof: (id: number) => void;
    sendResize?: (id: number, rows: number, cols: number) => void;
    cleanup: (id: number) => void;
};
/**
 * A running exec process that is both a Promise and an AsyncIterable.
 *
 * Usage:
 * ```typescript
 * // Await for buffered result (strings)
 * const result = await vm.exec(['echo', 'hello']);
 * console.log(result.stdout);
 *
 * // Iterate for streaming output
 * for await (const chunk of vm.exec(['tail', '-f', 'log'])) {
 *   console.log(chunk);
 * }
 *
 * // Interactive with stdin
 * const proc = vm.exec(['bash'], { stdin: true, pty: true });
 * proc.write('ls\n');
 * for await (const chunk of proc) {
 *   process.stdout.write(chunk);
 * }
 * ```
 */
export declare class ExecProcess implements PromiseLike<ExecResult>, AsyncIterable<string> {
    private readonly session;
    private readonly callbacks;
    private attached;
    constructor(session: ExecSession, callbacks: ExecProcessCallbacks);
    /** The process ID */
    get id(): number;
    /**
     * Promise interface - await this to get the buffered result.
     */
    then<TResult1 = ExecResult, TResult2 = never>(onfulfilled?: ((value: ExecResult) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    /**
     * Catch interface for promise compatibility.
     */
    catch<TResult = never>(onrejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null): Promise<ExecResult | TResult>;
    /**
     * Finally interface for promise compatibility.
     */
    finally(onfinally?: (() => void) | null): Promise<ExecResult>;
    /**
     * The underlying result promise.
     */
    get result(): Promise<ExecResult>;
    /**
     * Write data to stdin (only if stdin was enabled).
     */
    write(data: string | Buffer): void;
    /**
     * Close stdin (only if stdin was enabled).
     */
    end(): void;
    /**
     * Resize the PTY if supported by the underlying transport.
     */
    resize(rows: number, cols: number): void;
    /**
     * Async iterator over stdout lines/chunks as strings.
     * Default iteration yields stdout only.
     */
    [Symbol.asyncIterator](): AsyncIterator<string>;
    /**
     * Async iterator over labeled output chunks from both stdout and stderr.
     */
    output(): AsyncIterable<OutputChunk>;
    /**
     * Async iterator over lines from stdout.
     */
    lines(): AsyncIterable<string>;
    /**
     * Direct access to stdout stream.
     */
    get stdout(): Readable;
    /**
     * Direct access to stderr stream.
     */
    get stderr(): Readable;
    /**
     * Attach to terminal streams for interactive use.
     * Handles raw mode, stdin piping, and cleanup automatically.
     *
     * @param stdin - Input stream (e.g., process.stdin)
     * @param stdout - Output stream for stdout (e.g., process.stdout)
     * @param stderr - Output stream for stderr (optional, defaults to stdout)
     */
    attach(stdin: NodeJS.ReadStream, stdout: NodeJS.WriteStream, stderr?: NodeJS.WriteStream): void;
}
/**
 * Create an ExecSession with the given parameters.
 */
export declare function createExecSession(id: number, options: {
    stdinEnabled: boolean;
    encoding?: BufferEncoding;
    signal?: AbortSignal;
}): ExecSession;
/**
 * Finish an ExecSession with a successful result.
 */
export declare function finishExecSession(session: ExecSession, exitCode: number, signal?: number): void;
/**
 * Reject an ExecSession with an error.
 */
export declare function rejectExecSession(session: ExecSession, error: Error): void;
//# sourceMappingURL=exec.d.ts.map