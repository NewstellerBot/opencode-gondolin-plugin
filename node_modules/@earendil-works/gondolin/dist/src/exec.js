"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecProcess = exports.ExecResult = void 0;
exports.createExecSession = createExecSession;
exports.finishExecSession = finishExecSession;
exports.rejectExecSession = rejectExecSession;
const stream_1 = require("stream");
const DEFAULT_ENCODING = "utf-8";
/**
 * Result of a completed exec command.
 */
class ExecResult {
    constructor(id, exitCode, stdout, stderr, signal, encoding = DEFAULT_ENCODING) {
        this.id = id;
        this.exitCode = exitCode;
        this._stdout = stdout;
        this._stderr = stderr;
        this.signal = signal;
        this._encoding = encoding;
    }
    /** stdout as string */
    get stdout() {
        return this._stdout.toString(this._encoding);
    }
    /** stderr as string */
    get stderr() {
        return this._stderr.toString(this._encoding);
    }
    /** stdout as Buffer (for binary data) */
    get stdoutBuffer() {
        return this._stdout;
    }
    /** stderr as Buffer (for binary data) */
    get stderrBuffer() {
        return this._stderr;
    }
    /** Parse stdout as JSON */
    json() {
        return JSON.parse(this.stdout);
    }
    /** Split stdout into lines */
    lines() {
        return this.stdout.split("\n").filter((line) => line.length > 0);
    }
    /** Check if the command succeeded (exit code 0) */
    get ok() {
        return this.exitCode === 0;
    }
    toString() {
        return this.stdout;
    }
}
exports.ExecResult = ExecResult;
/**
 * A running exec process that is both a Promise and an AsyncIterable.
 *
 * Usage:
 * ```typescript
 * // Await for buffered result (strings)
 * const result = await vm.exec(['echo', 'hello']);
 * console.log(result.stdout);
 *
 * // Iterate for streaming output
 * for await (const chunk of vm.exec(['tail', '-f', 'log'])) {
 *   console.log(chunk);
 * }
 *
 * // Interactive with stdin
 * const proc = vm.exec(['bash'], { stdin: true, pty: true });
 * proc.write('ls\n');
 * for await (const chunk of proc) {
 *   process.stdout.write(chunk);
 * }
 * ```
 */
class ExecProcess {
    constructor(session, callbacks) {
        this.attached = false;
        this.session = session;
        this.callbacks = callbacks;
    }
    /** The process ID */
    get id() {
        return this.session.id;
    }
    /**
     * Promise interface - await this to get the buffered result.
     */
    then(onfulfilled, onrejected) {
        return this.session.resultPromise.then(onfulfilled, onrejected);
    }
    /**
     * Catch interface for promise compatibility.
     */
    catch(onrejected) {
        return this.session.resultPromise.catch(onrejected);
    }
    /**
     * Finally interface for promise compatibility.
     */
    finally(onfinally) {
        return this.session.resultPromise.finally(onfinally);
    }
    /**
     * The underlying result promise.
     */
    get result() {
        return this.session.resultPromise;
    }
    /**
     * Write data to stdin (only if stdin was enabled).
     */
    write(data) {
        if (!this.session.stdinEnabled) {
            throw new Error("stdin was not enabled for this exec");
        }
        this.callbacks.sendStdin(this.session.id, data);
    }
    /**
     * Close stdin (only if stdin was enabled).
     */
    end() {
        if (!this.session.stdinEnabled) {
            throw new Error("stdin was not enabled for this exec");
        }
        this.callbacks.sendStdinEof(this.session.id);
    }
    /**
     * Resize the PTY if supported by the underlying transport.
     */
    resize(rows, cols) {
        if (!this.callbacks.sendResize)
            return;
        this.callbacks.sendResize(this.session.id, rows, cols);
    }
    /**
     * Async iterator over stdout lines/chunks as strings.
     * Default iteration yields stdout only.
     */
    async *[Symbol.asyncIterator]() {
        this.session.iterating = true;
        const encoding = this.session.encoding;
        for await (const chunk of this.session.stdout) {
            yield chunk.toString(encoding);
        }
    }
    /**
     * Async iterator over labeled output chunks from both stdout and stderr.
     */
    async *output() {
        this.session.iterating = true;
        const encoding = this.session.encoding;
        const queue = [];
        let resolveWait = null;
        let stdoutDone = false;
        let stderrDone = false;
        const push = (item) => {
            queue.push(item);
            if (resolveWait) {
                resolveWait();
                resolveWait = null;
            }
        };
        this.session.stdout.on("data", (chunk) => {
            push({ stream: "stdout", data: chunk });
        });
        this.session.stdout.on("end", () => {
            stdoutDone = true;
            if (stderrDone)
                push({ done: true });
        });
        this.session.stderr.on("data", (chunk) => {
            push({ stream: "stderr", data: chunk });
        });
        this.session.stderr.on("end", () => {
            stderrDone = true;
            if (stdoutDone)
                push({ done: true });
        });
        while (true) {
            if (queue.length === 0) {
                await new Promise((resolve) => {
                    resolveWait = resolve;
                });
            }
            const item = queue.shift();
            if ("done" in item)
                break;
            yield {
                stream: item.stream,
                data: item.data,
                text: item.data.toString(encoding),
            };
        }
    }
    /**
     * Async iterator over lines from stdout.
     */
    async *lines() {
        let buffer = "";
        const encoding = this.session.encoding;
        for await (const chunk of this.session.stdout) {
            buffer += chunk.toString(encoding);
            const lines = buffer.split("\n");
            buffer = lines.pop() ?? "";
            for (const line of lines) {
                yield line;
            }
        }
        if (buffer.length > 0) {
            yield buffer;
        }
    }
    /**
     * Direct access to stdout stream.
     */
    get stdout() {
        return this.session.stdout;
    }
    /**
     * Direct access to stderr stream.
     */
    get stderr() {
        return this.session.stderr;
    }
    /**
     * Attach to terminal streams for interactive use.
     * Handles raw mode, stdin piping, and cleanup automatically.
     *
     * @param stdin - Input stream (e.g., process.stdin)
     * @param stdout - Output stream for stdout (e.g., process.stdout)
     * @param stderr - Output stream for stderr (optional, defaults to stdout)
     */
    attach(stdin, stdout, stderr) {
        if (this.attached) {
            throw new Error("already attached");
        }
        this.attached = true;
        const stderrOut = stderr ?? stdout;
        const onResize = () => {
            if (!stdout.isTTY)
                return;
            const cols = stdout.columns;
            const rows = stdout.rows;
            if (typeof cols === "number" && typeof rows === "number") {
                this.resize(rows, cols);
            }
        };
        // Setup raw mode for TTY
        if (stdin.isTTY) {
            stdin.setRawMode(true);
        }
        stdin.resume();
        if (stdout.isTTY) {
            onResize();
            stdout.on("resize", onResize);
        }
        // Pipe stdin to process
        const onStdinData = (chunk) => {
            this.write(chunk);
        };
        const onStdinEnd = () => {
            this.end();
        };
        stdin.on("data", onStdinData);
        stdin.on("end", onStdinEnd);
        // Pipe output to stdout/stderr
        this.session.stdout.on("data", (chunk) => {
            stdout.write(chunk);
        });
        this.session.stderr.on("data", (chunk) => {
            stderrOut.write(chunk);
        });
        // Cleanup on exit
        this.session.resultPromise.finally(() => {
            stdin.off("data", onStdinData);
            stdin.off("end", onStdinEnd);
            if (stdout.isTTY) {
                stdout.off("resize", onResize);
            }
            if (stdin.isTTY) {
                stdin.setRawMode(false);
            }
            stdin.pause();
        });
    }
}
exports.ExecProcess = ExecProcess;
/**
 * Create an ExecSession with the given parameters.
 */
function createExecSession(id, options) {
    let resolve;
    let reject;
    const resultPromise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    const session = {
        id,
        stdout: new stream_1.PassThrough(),
        stderr: new stream_1.PassThrough(),
        stdoutChunks: [],
        stderrChunks: [],
        resolve,
        reject,
        resultPromise,
        stdinEnabled: options.stdinEnabled,
        encoding: options.encoding ?? DEFAULT_ENCODING,
        signal: options.signal,
        iterating: false,
        requestReady: false,
        pendingStdin: [],
        pendingResize: null,
    };
    // Output buffering is handled in VM.handleMessage to avoid
    // putting the streams into flowing mode before a consumer attaches.
    return session;
}
/**
 * Finish an ExecSession with a successful result.
 */
function finishExecSession(session, exitCode, signal) {
    const result = new ExecResult(session.id, exitCode, Buffer.concat(session.stdoutChunks), Buffer.concat(session.stderrChunks), signal, session.encoding);
    session.stdout.end();
    session.stderr.end();
    if (session.signal && session.signalListener) {
        session.signal.removeEventListener("abort", session.signalListener);
    }
    session.resolve(result);
}
/**
 * Reject an ExecSession with an error.
 */
function rejectExecSession(session, error) {
    session.stdout.end();
    session.stderr.end();
    if (session.signal && session.signalListener) {
        session.signal.removeEventListener("abort", session.signalListener);
    }
    session.reject(error);
}
//# sourceMappingURL=exec.js.map