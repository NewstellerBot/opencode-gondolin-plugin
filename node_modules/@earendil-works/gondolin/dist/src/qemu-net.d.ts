import { EventEmitter } from "events";
import { fetch as undiciFetch } from "undici";
import type { SandboxPolicy } from "./policy";
export type HttpFetch = typeof undiciFetch;
export type HttpHookRequest = {
    method: string;
    url: string;
    headers: Record<string, string>;
    body: Buffer | null;
};
export type HttpHookResponse = {
    status: number;
    statusText: string;
    headers: Record<string, string>;
    body: Buffer;
};
export type HttpAllowInfo = {
    hostname: string;
    ip: string;
    family: 4 | 6;
    port: number;
    protocol: "http" | "https";
};
export declare class HttpRequestBlockedError extends Error {
    status: number;
    statusText: string;
    constructor(message?: string, status?: number, statusText?: string);
}
export type HttpHooks = {
    isAllowed?: (info: HttpAllowInfo) => Promise<boolean> | boolean;
    onRequest?: (request: HttpHookRequest) => Promise<HttpHookRequest | void> | HttpHookRequest | void;
    onResponse?: (response: HttpHookResponse, request: HttpHookRequest) => Promise<HttpHookResponse | void> | HttpHookResponse | void;
};
export type QemuNetworkOptions = {
    socketPath: string;
    gatewayIP?: string;
    vmIP?: string;
    gatewayMac?: Buffer;
    vmMac?: Buffer;
    debug?: boolean;
    fetch?: HttpFetch;
    httpHooks?: HttpHooks;
    mitmCertDir?: string;
    policy?: SandboxPolicy;
};
export declare class QemuNetworkBackend extends EventEmitter {
    private readonly options;
    private server;
    private socket;
    private waitingDrain;
    private stack;
    private readonly udpSessions;
    private readonly tcpSessions;
    private readonly mitmDir;
    private caPromise;
    private tlsContexts;
    private tlsContextPromises;
    private policy;
    constructor(options: QemuNetworkOptions);
    start(): void;
    stop(): void;
    setPolicy(policy: SandboxPolicy | null): void;
    getPolicy(): SandboxPolicy | null;
    private attachSocket;
    private detachSocket;
    private resetStack;
    private flush;
    private cleanupSessions;
    private handleUdpSend;
    private handleTcpConnect;
    private handleTcpSend;
    private handleTcpClose;
    private handleTcpPause;
    private handleTcpResume;
    private ensureTcpSocket;
    private ensureTlsSession;
    private handlePlainHttpData;
    private handleTlsHttpData;
    private handleHttpDataWithWriter;
    private handleTlsData;
    private parseHttpRequest;
    private decodeChunkedBody;
    private fetchAndRespond;
    private sendHttpResponseHead;
    private sendHttpResponse;
    private sendChunkedBody;
    private sendStreamBody;
    private respondWithError;
    private buildFetchUrl;
    private resolveHostname;
    private ensureRequestAllowed;
    private applyRequestHooks;
    private createCheckedDispatcher;
    private getMitmDir;
    private ensureCaAsync;
    private loadOrCreateCa;
    private getTlsContextAsync;
    private createTlsContext;
    private ensureLeafCertificateAsync;
    private stripHopByHopHeaders;
    private headersToRecord;
}
//# sourceMappingURL=qemu-net.d.ts.map