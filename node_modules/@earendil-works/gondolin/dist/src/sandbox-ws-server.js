"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxWsServer = void 0;
exports.resolveSandboxWsServerOptions = resolveSandboxWsServerOptions;
exports.resolveSandboxWsServerOptionsAsync = resolveSandboxWsServerOptionsAsync;
const fs_1 = __importDefault(require("fs"));
const net_1 = __importDefault(require("net"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const crypto_1 = require("crypto");
const child_process_1 = require("child_process");
const events_1 = require("events");
const ws_1 = require("ws");
const virtio_protocol_1 = require("./virtio-protocol");
const ws_protocol_1 = require("./ws-protocol");
const sandbox_controller_1 = require("./sandbox-controller");
const qemu_net_1 = require("./qemu-net");
const vfs_1 = require("./vfs");
const debug_1 = require("./debug");
const assets_1 = require("./assets");
const MAX_REQUEST_ID = 0xffffffff;
const DEFAULT_MAX_JSON_BYTES = 256 * 1024;
const DEFAULT_MAX_STDIN_BYTES = 64 * 1024;
const { errno: ERRNO } = os_1.default.constants;
/**
 * Get default guest asset paths from local development checkout.
 * Returns undefined for each path if not found locally.
 */
function getLocalGuestAssets() {
    // Handle both source (src/) and compiled (dist/src/) paths
    // We need to find the repo root where guest/ lives
    const possibleRepoRoots = [
        path_1.default.resolve(__dirname, "../.."), // from src/: -> host/ -> gondolin/
        path_1.default.resolve(__dirname, "../../.."), // from dist/src/: -> dist/ -> host/ -> gondolin/
    ];
    for (const repoRoot of possibleRepoRoots) {
        const devPath = path_1.default.join(repoRoot, "guest", "image", "out");
        const kernelPath = path_1.default.join(devPath, "vmlinuz-virt");
        const initrdPath = path_1.default.join(devPath, "initramfs.cpio.lz4");
        const rootfsPath = path_1.default.join(devPath, "rootfs.ext4");
        // Check if local dev paths exist
        if (fs_1.default.existsSync(kernelPath) &&
            fs_1.default.existsSync(initrdPath) &&
            fs_1.default.existsSync(rootfsPath)) {
            return { kernelPath, initrdPath, rootfsPath };
        }
    }
    return {};
}
/**
 * Resolve server options synchronously.
 *
 * This version uses local development paths if available. For production use,
 * prefer `resolveSandboxWsServerOptionsAsync` which will download assets if needed.
 *
 * @param options User-provided options
 * @param assets Optional pre-resolved guest assets (from ensureGuestAssets)
 */
function resolveSandboxWsServerOptions(options = {}, assets) {
    // Try local dev paths if no assets provided
    const localAssets = assets ?? getLocalGuestAssets();
    const defaultKernel = localAssets.kernelPath;
    const defaultInitrd = localAssets.initrdPath;
    const defaultRootfs = localAssets.rootfsPath;
    // we are running into length limits on macos on the default temp dir
    const tmpDir = process.platform === "darwin" ? "/tmp" : os_1.default.tmpdir();
    const defaultVirtio = path_1.default.resolve(tmpDir, `gondolin-virtio-${(0, crypto_1.randomUUID)().slice(0, 8)}.sock`);
    const defaultVirtioFs = path_1.default.resolve(tmpDir, `gondolin-virtio-fs-${(0, crypto_1.randomUUID)().slice(0, 8)}.sock`);
    const defaultNetSock = path_1.default.resolve(tmpDir, `gondolin-net-${(0, crypto_1.randomUUID)().slice(0, 8)}.sock`);
    const defaultNetMac = "02:00:00:00:00:01";
    const hostArch = detectHostArch();
    const defaultQemu = hostArch === "arm64" ? "qemu-system-aarch64" : "qemu-system-x86_64";
    const defaultMemory = "1G";
    const debugFlags = (0, debug_1.parseDebugEnv)();
    // If no kernel path can be determined, we'll need to fetch assets later
    const kernelPath = options.kernelPath ?? defaultKernel;
    const initrdPath = options.initrdPath ?? defaultInitrd;
    const rootfsPath = options.rootfsPath ?? defaultRootfs;
    if (!kernelPath || !initrdPath || !rootfsPath) {
        throw new Error("Guest assets not found. Either:\n" +
            "  1. Run from the gondolin repository with built guest images\n" +
            "  2. Use SandboxWsServer.create() to auto-download assets\n" +
            "  3. Explicitly provide kernelPath, initrdPath, and rootfsPath options\n" +
            "  4. Set GONDOLIN_GUEST_DIR to a directory containing the assets");
    }
    return {
        host: options.host ?? "127.0.0.1",
        port: options.port ?? 8080,
        qemuPath: options.qemuPath ?? defaultQemu,
        kernelPath,
        initrdPath,
        rootfsPath,
        memory: options.memory ?? defaultMemory,
        cpus: options.cpus ?? 2,
        virtioSocketPath: options.virtioSocketPath ?? defaultVirtio,
        virtioFsSocketPath: options.virtioFsSocketPath ?? defaultVirtioFs,
        netSocketPath: options.netSocketPath ?? defaultNetSock,
        netMac: options.netMac ?? defaultNetMac,
        netEnabled: options.netEnabled ?? true,
        netDebug: options.netDebug ?? debugFlags.has("net"),
        machineType: options.machineType,
        accel: options.accel,
        cpu: options.cpu,
        console: options.console,
        token: options.token ?? process.env.ELWING_TOKEN ?? process.env.SANDBOX_WS_TOKEN,
        autoRestart: options.autoRestart ?? true,
        append: options.append,
        maxJsonBytes: options.maxJsonBytes ?? DEFAULT_MAX_JSON_BYTES,
        maxStdinBytes: options.maxStdinBytes ?? DEFAULT_MAX_STDIN_BYTES,
        policy: options.policy ?? null,
        fetch: options.fetch,
        httpHooks: options.httpHooks,
        mitmCertDir: options.mitmCertDir,
        vfsProvider: options.vfsProvider ?? null,
    };
}
/**
 * Resolve server options asynchronously, downloading guest assets if needed.
 *
 * This is the recommended way to get resolved options for production use.
 */
async function resolveSandboxWsServerOptionsAsync(options = {}) {
    // If all paths are explicitly provided, use sync version
    if (options.kernelPath && options.initrdPath && options.rootfsPath) {
        return resolveSandboxWsServerOptions(options);
    }
    // Check for local dev paths first
    const localAssets = getLocalGuestAssets();
    if (localAssets.kernelPath && localAssets.initrdPath && localAssets.rootfsPath) {
        return resolveSandboxWsServerOptions(options, localAssets);
    }
    // Download assets if needed
    const assets = await (0, assets_1.ensureGuestAssets)();
    return resolveSandboxWsServerOptions(options, assets);
}
let cachedHostArch = null;
function detectHostArch() {
    if (cachedHostArch !== null)
        return cachedHostArch;
    // Synchronous fallback for first call - will be replaced by async result
    if (process.arch === "arm64") {
        cachedHostArch = "arm64";
        return cachedHostArch;
    }
    // For macOS x64, we need async detection for Rosetta - return x64 for now
    // and let the async detection update it if needed
    cachedHostArch = process.arch;
    return cachedHostArch;
}
// Async detection that runs at module load
async function detectHostArchAsync() {
    if (process.arch === "arm64")
        return "arm64";
    if (process.platform === "darwin" && process.arch === "x64") {
        try {
            const result = await new Promise((resolve, reject) => {
                (0, child_process_1.execFile)("sysctl", ["-n", "hw.optional.arm64"], (err, stdout) => {
                    if (err)
                        reject(err);
                    else
                        resolve(stdout.trim());
                });
            });
            if (result === "1")
                return "arm64";
        }
        catch {
            // ignore
        }
    }
    return process.arch;
}
// Start async detection immediately and cache result
detectHostArchAsync().then((arch) => {
    cachedHostArch = arch;
});
class VirtioBridge {
    constructor(socketPath, maxPendingBytes = 8 * 1024 * 1024) {
        this.socketPath = socketPath;
        this.maxPendingBytes = maxPendingBytes;
        this.socket = null;
        this.server = null;
        this.reader = new virtio_protocol_1.FrameReader();
        this.reconnectTimer = null;
        this.pending = [];
        this.pendingBytes = 0;
        this.waitingDrain = false;
        this.allowReconnect = true;
    }
    connect() {
        if (this.server)
            return;
        this.allowReconnect = true;
        if (!fs_1.default.existsSync(path_1.default.dirname(this.socketPath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(this.socketPath), { recursive: true });
        }
        fs_1.default.rmSync(this.socketPath, { force: true });
        const server = net_1.default.createServer((socket) => {
            this.attachSocket(socket);
        });
        this.server = server;
        server.on("error", (err) => {
            this.onError?.(err);
            server.close();
        });
        server.on("close", () => {
            this.server = null;
            this.scheduleReconnect();
        });
        server.listen(this.socketPath);
    }
    disconnect() {
        this.allowReconnect = false;
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
        if (this.socket) {
            this.socket.end();
            this.socket = null;
        }
        if (this.server) {
            this.server.close();
            this.server = null;
        }
        this.waitingDrain = false;
    }
    send(message) {
        if (!this.socket) {
            this.connect();
        }
        const frame = (0, virtio_protocol_1.encodeFrame)(message);
        if (this.pending.length === 0 && !this.waitingDrain) {
            return this.writeFrame(frame);
        }
        const queued = this.queueFrame(frame);
        if (queued && this.socket && this.socket.writable && !this.waitingDrain) {
            this.flushPending();
        }
        return queued;
    }
    writeFrame(frame) {
        if (!this.socket || !this.socket.writable) {
            return this.queueFrame(frame);
        }
        const ok = this.socket.write(frame);
        if (!ok) {
            this.waitingDrain = true;
            this.socket.once("drain", () => {
                this.waitingDrain = false;
                this.flushPending();
            });
        }
        return true;
    }
    queueFrame(frame) {
        if (this.pendingBytes + frame.length > this.maxPendingBytes) {
            return false;
        }
        this.pending.push(frame);
        this.pendingBytes += frame.length;
        return true;
    }
    flushPending() {
        if (!this.socket || this.waitingDrain || !this.socket.writable)
            return;
        while (this.pending.length > 0) {
            const frame = this.pending.shift();
            this.pendingBytes -= frame.length;
            const ok = this.writeFrame(frame);
            if (!ok || this.waitingDrain)
                return;
        }
    }
    attachSocket(socket) {
        if (this.socket) {
            this.socket.destroy();
        }
        this.socket = socket;
        this.waitingDrain = false;
        socket.on("data", (chunk) => {
            this.reader.push(chunk, (frame) => {
                try {
                    const message = (0, virtio_protocol_1.decodeMessage)(frame);
                    this.onMessage?.(message);
                }
                catch (err) {
                    this.onError?.(err);
                    this.handleDisconnect();
                }
            });
        });
        socket.on("error", (err) => {
            this.onError?.(err);
            this.handleDisconnect();
        });
        socket.on("end", () => {
            this.handleDisconnect();
        });
        socket.on("close", () => {
            this.handleDisconnect();
        });
        this.flushPending();
    }
    handleDisconnect() {
        if (this.socket) {
            this.socket.destroy();
            this.socket = null;
        }
        this.waitingDrain = false;
    }
    scheduleReconnect() {
        if (!this.allowReconnect || this.reconnectTimer)
            return;
        this.reconnectTimer = setTimeout(() => {
            this.reconnectTimer = null;
            if (this.allowReconnect) {
                this.connect();
            }
        }, 500);
    }
}
function parseMac(value) {
    const parts = value.split(":");
    if (parts.length !== 6)
        return null;
    const bytes = parts.map((part) => Number.parseInt(part, 16));
    if (bytes.some((byte) => !Number.isFinite(byte) || byte < 0 || byte > 255))
        return null;
    return Buffer.from(bytes);
}
function isValidRequestId(value) {
    return (typeof value === "number" &&
        Number.isInteger(value) &&
        value >= 0 &&
        value <= MAX_REQUEST_ID);
}
function estimateBase64Bytes(value) {
    const len = value.length;
    const padding = value.endsWith("==") ? 2 : value.endsWith("=") ? 1 : 0;
    return Math.floor((len * 3) / 4) - padding;
}
function validateToken(headers, token) {
    if (!token)
        return true;
    const headerToken = headers["x-elwing-token"] ?? headers["x-sandbox-token"];
    if (typeof headerToken === "string" && headerToken === token)
        return true;
    if (Array.isArray(headerToken) && headerToken.includes(token))
        return true;
    const auth = headers.authorization;
    if (typeof auth === "string" && auth.startsWith("Bearer ")) {
        return auth.slice("Bearer ".length) === token;
    }
    return false;
}
function safeSend(ws, data, options) {
    if (ws.readyState !== ws_1.WebSocket.OPEN)
        return false;
    try {
        if (options) {
            ws.send(data, options);
        }
        else {
            ws.send(data);
        }
        return true;
    }
    catch {
        return false;
    }
}
function sendJson(ws, message) {
    return safeSend(ws, JSON.stringify(message));
}
function sendBinary(ws, data) {
    return safeSend(ws, data, { binary: true });
}
function sendError(ws, error) {
    return sendJson(ws, error);
}
function formatHost(host) {
    return host.includes(":") ? `[${host}]` : host;
}
function resolveAddress(host, address) {
    if (!address || typeof address === "string") {
        const formattedHost = formatHost(host);
        return {
            host,
            port: 0,
            url: `ws://${formattedHost}`,
        };
    }
    const formattedHost = formatHost(host);
    return {
        host,
        port: address.port,
        url: `ws://${formattedHost}:${address.port}`,
    };
}
class SandboxWsServer extends events_1.EventEmitter {
    /**
     * Create a SandboxWsServer, downloading guest assets if needed.
     *
     * This is the recommended way to create a server in production, as it will
     * automatically download the guest image if it's not available locally.
     *
     * @param options Server configuration options
     * @returns A configured SandboxWsServer instance
     */
    static async create(options = {}) {
        const resolvedOptions = await resolveSandboxWsServerOptionsAsync(options);
        return new SandboxWsServer(resolvedOptions);
    }
    /**
     * Create a SandboxWsServer synchronously.
     *
     * This constructor requires that guest assets are available locally (either
     * in a development checkout or via GONDOLIN_GUEST_DIR). For automatic asset
     * downloading, use the async `SandboxWsServer.create()` factory instead.
     *
     * @param options Server configuration options (or pre-resolved options)
     */
    constructor(options = {}) {
        super();
        this.wss = null;
        this.fsService = null;
        this.inflight = new Map();
        this.stdinAllowed = new Set();
        this.startPromise = null;
        this.stopPromise = null;
        this.address = null;
        this.qemuLogBuffer = "";
        this.status = "stopped";
        this.bootConfig = null;
        this.activeClient = null;
        this.on("error", (err) => {
            const message = err instanceof Error ? err.message : String(err);
            this.emit("log", `[error] ${message}`);
        });
        // Detect if we received pre-resolved options (from static create())
        // by checking for a field that's required in resolved but computed in unresolved
        const isResolved = "maxJsonBytes" in options && "maxStdinBytes" in options &&
            typeof options.maxJsonBytes === "number" && typeof options.maxStdinBytes === "number";
        this.options = isResolved
            ? options
            : resolveSandboxWsServerOptions(options);
        this.policy = this.options.policy;
        this.vfsProvider = this.options.vfsProvider
            ? this.options.vfsProvider instanceof vfs_1.SandboxVfsProvider
                ? this.options.vfsProvider
                : new vfs_1.SandboxVfsProvider(this.options.vfsProvider)
            : null;
        const hostArch = detectHostArch();
        const consoleDevice = hostArch === "arm64" ? "ttyAMA0" : "ttyS0";
        this.baseAppend = this.options.append ?? `console=${consoleDevice} initramfs_async=1`;
        const sandboxConfig = {
            qemuPath: this.options.qemuPath,
            kernelPath: this.options.kernelPath,
            initrdPath: this.options.initrdPath,
            rootfsPath: this.options.rootfsPath,
            memory: this.options.memory,
            cpus: this.options.cpus,
            virtioSocketPath: this.options.virtioSocketPath,
            virtioFsSocketPath: this.options.virtioFsSocketPath,
            netSocketPath: this.options.netEnabled ? this.options.netSocketPath : undefined,
            netMac: this.options.netMac,
            append: this.baseAppend,
            machineType: this.options.machineType,
            accel: this.options.accel,
            cpu: this.options.cpu,
            console: this.options.console,
            autoRestart: this.options.autoRestart,
        };
        this.controller = new sandbox_controller_1.SandboxController(sandboxConfig);
        this.bridge = new VirtioBridge(this.options.virtioSocketPath);
        this.fsBridge = new VirtioBridge(this.options.virtioFsSocketPath);
        this.fsService = this.vfsProvider
            ? new vfs_1.FsRpcService(this.vfsProvider, {
                logger: (message) => this.emit("log", message),
            })
            : null;
        const mac = parseMac(this.options.netMac) ?? Buffer.from([0x02, 0x00, 0x00, 0x00, 0x00, 0x01]);
        this.network = this.options.netEnabled
            ? new qemu_net_1.QemuNetworkBackend({
                socketPath: this.options.netSocketPath,
                vmMac: mac,
                debug: this.options.netDebug,
                policy: this.policy ?? undefined,
                fetch: this.options.fetch,
                httpHooks: this.options.httpHooks,
                mitmCertDir: this.options.mitmCertDir,
            })
            : null;
        if (this.network) {
            this.network.on("log", (message) => {
                this.emit("log", message);
            });
            this.network.on("error", (err) => {
                this.emit("error", err);
            });
            this.network.on("policy", (policy) => {
                this.emit("policy", policy);
            });
        }
        this.controller.on("state", (state) => {
            this.status = state;
            if (state === "running") {
                this.bridge.connect();
                this.fsBridge.connect();
            }
            if (state === "stopped") {
                this.failInflight("sandbox_stopped", "sandbox is not running");
            }
            if (!this.wss)
                return;
            for (const client of this.wss.clients) {
                sendJson(client, { type: "status", state });
            }
            this.emit("state", state);
        });
        this.controller.on("exit", (info) => {
            if (this.qemuLogBuffer.length > 0) {
                this.emit("log", `[qemu] ${this.qemuLogBuffer}`);
                this.qemuLogBuffer = "";
            }
            this.failInflight("sandbox_stopped", "sandbox exited");
            this.emit("exit", info);
        });
        this.controller.on("log", (chunk) => {
            this.qemuLogBuffer += chunk;
            let newlineIndex = this.qemuLogBuffer.indexOf("\n");
            while (newlineIndex !== -1) {
                const line = this.qemuLogBuffer.slice(0, newlineIndex + 1);
                this.qemuLogBuffer = this.qemuLogBuffer.slice(newlineIndex + 1);
                this.emit("log", `[qemu] ${line}`);
                newlineIndex = this.qemuLogBuffer.indexOf("\n");
            }
        });
        this.bridge.onMessage = (message) => {
            if (!isValidRequestId(message.id)) {
                return;
            }
            if (message.t === "exec_output") {
                const client = this.inflight.get(message.id);
                if (!client)
                    return;
                const data = message.p.data;
                try {
                    if (!sendBinary(client, (0, ws_protocol_1.encodeOutputFrame)(message.id, message.p.stream, data))) {
                        this.inflight.delete(message.id);
                        this.stdinAllowed.delete(message.id);
                    }
                }
                catch {
                    this.inflight.delete(message.id);
                    this.stdinAllowed.delete(message.id);
                }
            }
            else if (message.t === "exec_response") {
                const client = this.inflight.get(message.id);
                if (client) {
                    sendJson(client, {
                        type: "exec_response",
                        id: message.id,
                        exit_code: message.p.exit_code,
                        signal: message.p.signal,
                    });
                }
                this.inflight.delete(message.id);
                this.stdinAllowed.delete(message.id);
            }
            else if (message.t === "error") {
                const client = this.inflight.get(message.id);
                if (client) {
                    sendError(client, {
                        type: "error",
                        id: message.id,
                        code: message.p.code,
                        message: message.p.message,
                    });
                }
                this.inflight.delete(message.id);
                this.stdinAllowed.delete(message.id);
            }
        };
        this.fsBridge.onMessage = (message) => {
            if (!isValidRequestId(message.id)) {
                return;
            }
            if (message.t !== "fs_request") {
                return;
            }
            if (!this.fsService) {
                this.fsBridge.send({
                    v: 1,
                    t: "fs_response",
                    id: message.id,
                    p: {
                        op: message.p.op,
                        err: ERRNO.ENOSYS,
                        message: "filesystem service unavailable",
                    },
                });
                return;
            }
            void this.fsService
                .handleRequest(message)
                .then((response) => {
                if (!this.fsBridge.send(response)) {
                    this.emit("error", new Error("[fs] virtio bridge queue exceeded"));
                }
            })
                .catch((err) => {
                const detail = err instanceof Error ? err.message : "fs handler error";
                this.fsBridge.send({
                    v: 1,
                    t: "fs_response",
                    id: message.id,
                    p: {
                        op: message.p.op,
                        err: ERRNO.EIO,
                        message: detail,
                    },
                });
                this.emit("error", err instanceof Error ? err : new Error(detail));
            });
        };
        this.bridge.onError = (err) => {
            const message = err instanceof Error ? err.message : "unknown error";
            this.emit("error", new Error(`[virtio] decode error: ${message}`));
            this.failInflight("protocol_error", "virtio decode error");
        };
        this.fsBridge.onError = (err) => {
            const message = err instanceof Error ? err.message : "unknown error";
            this.emit("error", new Error(`[fs] decode error: ${message}`));
        };
    }
    getAddress() {
        return this.address;
    }
    getUrl() {
        return this.address?.url ?? null;
    }
    getState() {
        return this.status;
    }
    getPolicy() {
        return this.policy;
    }
    getVfsProvider() {
        return this.vfsProvider;
    }
    getFsMetrics() {
        return this.fsService?.metrics ?? null;
    }
    setPolicy(policy) {
        this.policy = policy;
        this.network?.setPolicy(policy);
        this.emit("policy", policy);
    }
    async start() {
        if (this.startPromise)
            return this.startPromise;
        this.startPromise = this.startInternal().finally(() => {
            this.startPromise = null;
        });
        return this.startPromise;
    }
    async stop() {
        if (this.stopPromise)
            return this.stopPromise;
        this.stopPromise = this.stopInternal().finally(() => {
            this.stopPromise = null;
        });
        return this.stopPromise;
    }
    async startInternal() {
        if (this.wss) {
            return this.address ?? resolveAddress(this.options.host, this.wss.address());
        }
        this.wss = new ws_1.WebSocketServer({
            host: this.options.host,
            port: this.options.port,
            maxPayload: this.options.maxJsonBytes,
            verifyClient: (info, done) => {
                if (!validateToken(info.req.headers, this.options.token)) {
                    done(false, 401, "Unauthorized");
                    return;
                }
                done(true);
            },
        });
        this.wss.on("connection", (ws) => this.handleConnection(ws));
        this.wss.on("close", () => {
            this.wss = null;
            this.address = null;
        });
        this.network?.start();
        this.bridge.connect();
        this.fsBridge.connect();
        const address = await new Promise((resolve, reject) => {
            const handleError = (err) => {
                cleanup();
                reject(err);
            };
            const handleListening = () => {
                cleanup();
                const resolved = resolveAddress(this.options.host, this.wss?.address() ?? null);
                this.address = resolved;
                resolve(resolved);
            };
            const cleanup = () => {
                this.wss?.off("error", handleError);
                this.wss?.off("listening", handleListening);
            };
            this.wss?.once("error", handleError);
            this.wss?.once("listening", handleListening);
        });
        return address;
    }
    async stopInternal() {
        this.failInflight("server_shutdown", "server is shutting down");
        await this.controller.stop();
        this.bridge.disconnect();
        this.fsBridge.disconnect();
        await this.fsService?.close();
        this.network?.stop();
        if (this.wss) {
            for (const client of this.wss.clients) {
                client.terminate();
            }
            await new Promise((resolve) => {
                let finished = false;
                const finish = () => {
                    if (finished)
                        return;
                    finished = true;
                    clearTimeout(timeout);
                    resolve();
                };
                const timeout = setTimeout(() => {
                    finish();
                }, 1000);
                this.wss?.close(() => finish());
            });
        }
        this.wss = null;
        this.address = null;
    }
    handleConnection(ws) {
        if (this.activeClient) {
            sendError(ws, {
                type: "error",
                code: "client_busy",
                message: "only one client connection is allowed",
            });
            ws.close();
            return;
        }
        if (!sendJson(ws, { type: "status", state: this.controller.getState() })) {
            ws.close();
            return;
        }
        this.activeClient = ws;
        ws.on("message", (data, isBinary) => {
            if (isBinary) {
                sendError(ws, {
                    type: "error",
                    code: "invalid_message",
                    message: "binary input frames are not supported",
                });
                return;
            }
            const size = typeof data === "string"
                ? Buffer.byteLength(data)
                : Buffer.isBuffer(data)
                    ? data.length
                    : Array.isArray(data)
                        ? data.reduce((total, chunk) => total + chunk.length, 0)
                        : data.byteLength;
            if (size > this.options.maxJsonBytes) {
                sendError(ws, {
                    type: "error",
                    code: "payload_too_large",
                    message: "message exceeds size limit",
                });
                return;
            }
            let message;
            try {
                message = JSON.parse(data.toString());
            }
            catch {
                sendError(ws, {
                    type: "error",
                    code: "invalid_json",
                    message: "failed to parse JSON",
                });
                return;
            }
            if (message.type === "boot") {
                void this.handleBoot(ws, message);
                return;
            }
            if (!this.bootConfig && message.type !== "policy") {
                sendError(ws, {
                    type: "error",
                    code: "missing_boot",
                    message: "boot configuration required before commands",
                });
                return;
            }
            if (message.type === "exec") {
                this.handleExec(ws, message);
            }
            else if (message.type === "stdin") {
                this.handleStdin(ws, message);
            }
            else if (message.type === "pty_resize") {
                this.handlePtyResize(ws, message);
            }
            else if (message.type === "lifecycle") {
                if (message.action === "restart") {
                    void this.controller.restart();
                }
                else if (message.action === "shutdown") {
                    void this.controller.stop();
                }
            }
            else if (message.type === "policy") {
                this.handlePolicy(ws, message);
            }
            else {
                sendError(ws, {
                    type: "error",
                    code: "unknown_type",
                    message: "unsupported message type",
                });
            }
        });
        ws.on("close", () => {
            if (this.activeClient === ws) {
                this.activeClient = null;
            }
            for (const [id, client] of this.inflight.entries()) {
                if (client === ws) {
                    this.inflight.delete(id);
                    this.stdinAllowed.delete(id);
                }
            }
        });
    }
    async handleBoot(ws, message) {
        let config;
        try {
            config = normalizeSandboxFsConfig(message);
        }
        catch (err) {
            const error = err instanceof Error ? err.message : String(err);
            sendError(ws, {
                type: "error",
                code: "invalid_request",
                message: error,
            });
            return;
        }
        const changed = !this.bootConfig || !isSameSandboxFsConfig(this.bootConfig, config);
        this.bootConfig = config;
        const append = buildSandboxfsAppend(this.baseAppend, config);
        this.controller.setAppend(append);
        const state = this.controller.getState();
        if (changed) {
            if (state === "running" || state === "starting") {
                await this.controller.restart();
                return;
            }
        }
        if (state === "stopped") {
            await this.controller.start();
        }
        sendJson(ws, { type: "status", state: this.controller.getState() });
    }
    handleExec(ws, message) {
        if (!isValidRequestId(message.id) || !message.cmd) {
            sendError(ws, {
                type: "error",
                code: "invalid_request",
                message: "exec requires uint32 id and cmd",
            });
            return;
        }
        if (this.inflight.has(message.id)) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "duplicate_id",
                message: "request id already in use",
            });
            return;
        }
        this.inflight.set(message.id, ws);
        if (message.stdin)
            this.stdinAllowed.add(message.id);
        const payload = {
            cmd: message.cmd,
            argv: message.argv ?? [],
            env: message.env ?? [],
            cwd: message.cwd,
            stdin: message.stdin ?? false,
            pty: message.pty ?? false,
        };
        if (!this.bridge.send((0, virtio_protocol_1.buildExecRequest)(message.id, payload))) {
            this.inflight.delete(message.id);
            this.stdinAllowed.delete(message.id);
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "queue_full",
                message: "virtio bridge queue exceeded",
            });
        }
    }
    handleStdin(ws, message) {
        if (!isValidRequestId(message.id)) {
            sendError(ws, {
                type: "error",
                code: "invalid_request",
                message: "stdin requires a uint32 id",
            });
            return;
        }
        if (!this.inflight.has(message.id)) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "unknown_id",
                message: "request id not found",
            });
            return;
        }
        if (!this.stdinAllowed.has(message.id)) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "stdin_disabled",
                message: "stdin was not enabled for this request",
            });
            return;
        }
        const base64 = message.data ?? "";
        if (base64 && estimateBase64Bytes(base64) > this.options.maxStdinBytes) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "payload_too_large",
                message: "stdin chunk exceeds size limit",
            });
            return;
        }
        const data = base64 ? Buffer.from(base64, "base64") : Buffer.alloc(0);
        if (data.length > this.options.maxStdinBytes) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "payload_too_large",
                message: "stdin chunk exceeds size limit",
            });
            return;
        }
        if (!this.bridge.send((0, virtio_protocol_1.buildStdinData)(message.id, data, message.eof))) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "queue_full",
                message: "virtio bridge queue exceeded",
            });
        }
    }
    handlePtyResize(ws, message) {
        if (!isValidRequestId(message.id)) {
            sendError(ws, {
                type: "error",
                code: "invalid_request",
                message: "pty_resize requires a uint32 id",
            });
            return;
        }
        if (!this.inflight.has(message.id)) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "unknown_id",
                message: "request id not found",
            });
            return;
        }
        const rows = Number(message.rows);
        const cols = Number(message.cols);
        if (!Number.isFinite(rows) || !Number.isFinite(cols) || rows < 1 || cols < 1) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "invalid_request",
                message: "pty_resize requires positive rows and cols",
            });
            return;
        }
        if (!this.bridge.send((0, virtio_protocol_1.buildPtyResize)(message.id, Math.trunc(rows), Math.trunc(cols)))) {
            sendError(ws, {
                type: "error",
                id: message.id,
                code: "queue_full",
                message: "virtio bridge queue exceeded",
            });
        }
    }
    handlePolicy(_ws, message) {
        this.setPolicy(message.policy);
    }
    failInflight(code, message) {
        for (const [id, client] of this.inflight.entries()) {
            sendError(client, {
                type: "error",
                id,
                code,
                message,
            });
        }
        this.inflight.clear();
        this.stdinAllowed.clear();
    }
}
exports.SandboxWsServer = SandboxWsServer;
function normalizeSandboxFsConfig(message) {
    const fuseMount = normalizeMountPath(message.fuseMount ?? "/data", "fuseMount");
    const fuseBinds = normalizeBindList(message.fuseBinds ?? []);
    return {
        fuseMount,
        fuseBinds,
    };
}
function normalizeMountPath(value, field) {
    if (typeof value !== "string" || value.length === 0) {
        throw new Error(`${field} must be a non-empty string`);
    }
    let normalized = path_1.default.posix.normalize(value);
    if (!normalized.startsWith("/")) {
        throw new Error(`${field} must be an absolute path`);
    }
    if (normalized.length > 1 && normalized.endsWith("/")) {
        normalized = normalized.slice(0, -1);
    }
    if (normalized.includes("\0")) {
        throw new Error(`${field} contains null bytes`);
    }
    return normalized;
}
function normalizeBindList(value) {
    if (!Array.isArray(value)) {
        throw new Error("fuseBinds must be an array of absolute paths");
    }
    const seen = new Set();
    const binds = [];
    for (const entry of value) {
        const normalized = normalizeMountPath(entry, "fuseBinds");
        if (seen.has(normalized))
            continue;
        seen.add(normalized);
        binds.push(normalized);
    }
    binds.sort();
    return binds;
}
function isSameSandboxFsConfig(left, right) {
    if (left.fuseMount !== right.fuseMount)
        return false;
    if (left.fuseBinds.length !== right.fuseBinds.length)
        return false;
    for (let i = 0; i < left.fuseBinds.length; i += 1) {
        if (left.fuseBinds[i] !== right.fuseBinds[i])
            return false;
    }
    return true;
}
function buildSandboxfsAppend(baseAppend, config) {
    const pieces = [baseAppend.trim(), `sandboxfs.mount=${config.fuseMount}`];
    if (config.fuseBinds.length > 0) {
        pieces.push(`sandboxfs.bind=${config.fuseBinds.join(",")}`);
    }
    return pieces.filter((piece) => piece.length > 0).join(" ").trim();
}
//# sourceMappingURL=sandbox-ws-server.js.map