"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VM = exports.ExecResult = exports.ExecProcess = void 0;
const ws_1 = require("ws");
const stream_1 = require("stream");
const ws_protocol_1 = require("./ws-protocol");
const sandbox_ws_server_1 = require("./sandbox-ws-server");
const vfs_1 = require("./vfs");
const mitm_1 = require("./mitm");
const debug_1 = require("./debug");
const mounts_1 = require("./vfs/mounts");
const exec_1 = require("./exec");
const MAX_REQUEST_ID = 0xffffffff;
const DEFAULT_STDIN_CHUNK = 32 * 1024;
const VFS_READY_ATTEMPTS = 50;
const VFS_READY_SLEEP_SECONDS = 0.1;
function formatLog(message) {
    if (message.endsWith("\n"))
        return message;
    return `${message}\n`;
}
// Re-export types from exec.ts
var exec_2 = require("./exec");
Object.defineProperty(exports, "ExecProcess", { enumerable: true, get: function () { return exec_2.ExecProcess; } });
Object.defineProperty(exports, "ExecResult", { enumerable: true, get: function () { return exec_2.ExecResult; } });
class VM {
    /**
     * Create a VM instance, downloading guest assets if needed.
     *
     * This is the recommended way to create a VM in production, as it will
     * automatically download the guest image if it's not available locally.
     *
     * @param options VM configuration options
     * @returns A configured VM instance
     */
    static async create(options = {}) {
        // If connecting to remote URL, no need to resolve assets
        if (options.url) {
            return new VM(options);
        }
        // Resolve server options with async asset fetching
        const serverOptions = { ...options.server };
        // Build the combined server options
        if (options.fetch && serverOptions.fetch === undefined) {
            serverOptions.fetch = options.fetch;
        }
        if (options.httpHooks && serverOptions.httpHooks === undefined) {
            serverOptions.httpHooks = options.httpHooks;
        }
        if (serverOptions.host === undefined)
            serverOptions.host = "127.0.0.1";
        if (serverOptions.port === undefined)
            serverOptions.port = 0;
        if (options.policy && serverOptions.policy === undefined) {
            serverOptions.policy = options.policy;
        }
        if (options.memory && serverOptions.memory === undefined) {
            serverOptions.memory = options.memory;
        }
        if (options.cpus && serverOptions.cpus === undefined) {
            serverOptions.cpus = options.cpus;
        }
        // Resolve options with asset fetching
        const resolvedServerOptions = await (0, sandbox_ws_server_1.resolveSandboxWsServerOptionsAsync)(serverOptions);
        // Create VM with pre-resolved options
        return new VM(options, resolvedServerOptions);
    }
    /**
     * Create a VM instance synchronously.
     *
     * This constructor requires that guest assets are available locally (either
     * in a development checkout or via GONDOLIN_GUEST_DIR). For automatic asset
     * downloading, use the async `VM.create()` factory instead.
     *
     * @param options VM configuration options
     * @param resolvedServerOptions Optional pre-resolved server options (from VM.create())
     */
    constructor(options = {}, resolvedServerOptions) {
        this.resolvedServerOptions = null;
        this.ws = null;
        this.connectPromise = null;
        this.startPromise = null;
        this.stopPromise = null;
        this.statusPromise = null;
        this.statusResolve = null;
        this.statusReject = null;
        this.state = "unknown";
        this.stateWaiters = [];
        this.sessions = new Map();
        this.nextId = 1;
        this.bootSent = false;
        this.vfsReadyPromise = null;
        if (options.url && options.server) {
            throw new Error("VM cannot specify both url and server options");
        }
        this.token =
            options.token ?? process.env.ELWING_TOKEN ?? process.env.SANDBOX_WS_TOKEN;
        this.autoStart = options.autoStart ?? true;
        this.policy = options.policy ?? null;
        const mitmMounts = resolveMitmMounts(options.vfs, options.server?.mitmCertDir, options.server?.netEnabled ?? true);
        const resolvedVfs = resolveVmVfs(options.vfs, mitmMounts);
        this.vfs = resolvedVfs.provider;
        this.defaultEnv = options.env;
        let fuseMounts = resolvedVfs.mounts;
        let fuseConfig = resolveFuseConfig(options.vfs, fuseMounts);
        this.fuseMount = fuseConfig.fuseMount;
        this.fuseBinds = fuseConfig.fuseBinds;
        if (options.url) {
            this.url = options.url;
            this.server = null;
            return;
        }
        const serverOptions = { ...options.server };
        if (serverOptions.vfsProvider && options.vfs) {
            throw new Error("VM cannot specify both vfs and server.vfsProvider");
        }
        if (serverOptions.vfsProvider) {
            const injectedMounts = resolveMitmMounts(undefined, serverOptions.mitmCertDir, serverOptions.netEnabled ?? true);
            if (Object.keys(injectedMounts).length > 0) {
                const normalized = (0, mounts_1.normalizeMountMap)({
                    "/": serverOptions.vfsProvider,
                    ...injectedMounts,
                });
                this.vfs = wrapProvider(new mounts_1.MountRouterProvider(normalized), {});
                fuseMounts = { "/": serverOptions.vfsProvider, ...injectedMounts };
            }
            else {
                this.vfs = wrapProvider(serverOptions.vfsProvider, {});
                fuseMounts = { "/": serverOptions.vfsProvider };
            }
            fuseConfig = resolveFuseConfig(options.vfs, fuseMounts);
            this.fuseMount = fuseConfig.fuseMount;
            this.fuseBinds = fuseConfig.fuseBinds;
            serverOptions.vfsProvider = this.vfs;
        }
        if (options.fetch && serverOptions.fetch === undefined) {
            serverOptions.fetch = options.fetch;
        }
        if (options.httpHooks && serverOptions.httpHooks === undefined) {
            serverOptions.httpHooks = options.httpHooks;
        }
        if (this.vfs && serverOptions.vfsProvider === undefined) {
            serverOptions.vfsProvider = this.vfs;
        }
        if (serverOptions.host === undefined)
            serverOptions.host = "127.0.0.1";
        if (serverOptions.port === undefined)
            serverOptions.port = 0;
        if (this.policy && serverOptions.policy === undefined) {
            serverOptions.policy = this.policy;
        }
        if (options.memory && serverOptions.memory === undefined) {
            serverOptions.memory = options.memory;
        }
        if (options.cpus && serverOptions.cpus === undefined) {
            serverOptions.cpus = options.cpus;
        }
        const debugFlags = (0, debug_1.parseDebugEnv)();
        const netDebug = serverOptions.netDebug ?? debugFlags.has("net");
        if (netDebug !== undefined) {
            serverOptions.netDebug = netDebug;
        }
        // Handle VFS in resolved options
        if (resolvedServerOptions) {
            // Merge VFS provider into resolved options
            if (this.vfs) {
                resolvedServerOptions.vfsProvider = this.vfs;
            }
            this.server = new sandbox_ws_server_1.SandboxWsServer(resolvedServerOptions);
        }
        else {
            this.server = new sandbox_ws_server_1.SandboxWsServer(serverOptions);
        }
        if (netDebug) {
            this.server.on("log", (message) => {
                process.stderr.write(formatLog(message));
            });
            this.server.on("error", (err) => {
                const message = err instanceof Error ? err.message : String(err);
                process.stderr.write(formatLog(message));
            });
        }
        this.url = null;
    }
    getState() {
        return this.state;
    }
    getUrl() {
        return this.url;
    }
    getPolicy() {
        return this.policy;
    }
    getVfs() {
        return this.vfs;
    }
    setPolicy(policy) {
        this.policy = policy;
        if (this.server) {
            this.server.setPolicy(policy);
        }
        if (this.ws && this.ws.readyState === ws_1.WebSocket.OPEN) {
            this.sendJson({ type: "policy", policy });
        }
    }
    async start() {
        if (this.startPromise)
            return this.startPromise;
        this.startPromise = this.startInternal().finally(() => {
            this.startPromise = null;
        });
        return this.startPromise;
    }
    async stop() {
        if (this.stopPromise)
            return this.stopPromise;
        this.stopPromise = this.stopInternal().finally(() => {
            this.stopPromise = null;
        });
        return this.stopPromise;
    }
    async waitForReady() {
        await this.start();
        await this.ensureVfsReady();
    }
    /**
     * Execute a command in the sandbox.
     *
     * Returns an ExecProcess which can be:
     * - awaited for a buffered result with strings
     * - iterated for streaming output
     * - used with stdin via write()/end()
     *
     * @example
     * ```typescript
     * // Simple command - await for result
     * const result = await vm.exec(['echo', 'hello']);
     * console.log(result.stdout); // 'hello\n'
     *
     * // Streaming output
     * for await (const line of vm.exec(['tail', '-f', '/var/log/syslog'])) {
     *   console.log(line);
     * }
     *
     * // Interactive with stdin
     * const proc = vm.exec(['cat'], { stdin: true });
     * proc.write('hello\n');
     * proc.end();
     * const result = await proc;
     * ```
     */
    exec(command, options = {}) {
        const proc = this.execInternal(command, options);
        return proc;
    }
    /**
     * Start an interactive shell session.
     *
     * By default, attaches to process.stdin/stdout/stderr when running in a TTY.
     *
     * @example
     * ```typescript
     * // Simple interactive shell
     * const result = await vm.shell();
     * process.exit(result.exitCode);
     *
     * // Custom command
     * const result = await vm.shell({ command: 'python3' });
     *
     * // Manual control
     * const proc = vm.shell({ attach: false });
     * proc.write('ls\n');
     * for await (const chunk of proc) {
     *   process.stdout.write(chunk);
     * }
     * ```
     */
    shell(options = {}) {
        const command = options.command ?? ["bash", "-i"];
        const shouldAttach = options.attach ?? process.stdin.isTTY;
        const env = buildShellEnv(this.defaultEnv, options.env);
        const proc = this.exec(command, {
            env,
            cwd: options.cwd,
            stdin: true,
            pty: true,
            signal: options.signal,
        });
        if (shouldAttach) {
            proc.attach(process.stdin, process.stdout, process.stderr);
        }
        return proc;
    }
    execInternal(command, options) {
        const { cmd, argv } = normalizeCommand(command, options);
        const id = this.allocateId();
        const stdinSetting = options.stdin;
        const stdinEnabled = stdinSetting !== undefined && stdinSetting !== false;
        const session = (0, exec_1.createExecSession)(id, {
            stdinEnabled,
            encoding: options.encoding,
            signal: options.signal,
        });
        // Setup abort handling
        if (options.signal) {
            const onAbort = () => {
                (0, exec_1.rejectExecSession)(session, new Error("exec aborted"));
                this.sessions.delete(id);
            };
            options.signal.addEventListener("abort", onAbort, { once: true });
            session.signalListener = onAbort;
        }
        this.sessions.set(id, session);
        // Create the process handle
        const proc = new exec_1.ExecProcess(session, {
            sendStdin: (id, data) => this.sendStdinData(id, data),
            sendStdinEof: (id) => this.sendStdinEof(id),
            sendResize: (id, rows, cols) => this.sendPtyResize(id, rows, cols),
            cleanup: (id) => this.sessions.delete(id),
        });
        // Start the command asynchronously
        this.startExec(id, cmd, argv, options, session, stdinSetting);
        return proc;
    }
    async startExec(id, cmd, argv, options, session, stdinSetting) {
        try {
            await this.start();
            await this.ensureVfsReady();
            const mergedEnv = mergeEnvInputs(this.defaultEnv, options.env);
            const message = {
                type: "exec",
                id,
                cmd,
                argv: argv.length ? argv : undefined,
                env: mergedEnv && mergedEnv.length ? mergedEnv : undefined,
                cwd: options.cwd,
                stdin: session.stdinEnabled ? true : undefined,
                pty: options.pty ? true : undefined,
            };
            this.sendJson(message);
            this.markSessionReady(session);
            // Pipe stdin if provided (and not just `true`)
            if (session.stdinEnabled && stdinSetting !== true && stdinSetting !== undefined) {
                void this.pipeStdin(id, stdinSetting, session);
            }
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            (0, exec_1.rejectExecSession)(session, error);
            this.sessions.delete(id);
        }
    }
    async startInternal() {
        if (this.server) {
            const address = await this.server.start();
            this.url = address.url;
        }
        await this.ensureConnection();
        await this.ensureRunning();
    }
    async stopInternal() {
        if (this.server) {
            await this.server.stop();
            this.url = null;
        }
        if (this.vfs) {
            await this.vfs.close();
        }
        await this.disconnect();
        this.vfsReadyPromise = null;
    }
    allocateId() {
        for (let i = 0; i <= MAX_REQUEST_ID; i += 1) {
            const id = this.nextId;
            this.nextId = this.nextId + 1;
            if (this.nextId > MAX_REQUEST_ID)
                this.nextId = 1;
            if (!this.sessions.has(id))
                return id;
        }
        throw new Error("no available request ids");
    }
    async pipeStdin(id, input, session) {
        if (!session.stdinEnabled)
            return;
        try {
            if (typeof input === "string" || Buffer.isBuffer(input)) {
                this.sendStdinData(id, input);
                this.sendStdinEof(id);
            }
            else if (typeof input === "boolean") {
                // no-op for `true`
            }
            else {
                for await (const chunk of toAsyncIterable(input)) {
                    if (!this.sessions.has(id))
                        return;
                    this.sendStdinData(id, chunk);
                }
                if (this.sessions.has(id)) {
                    this.sendStdinEof(id);
                }
            }
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            (0, exec_1.rejectExecSession)(session, error);
            this.sessions.delete(id);
        }
    }
    markSessionReady(session) {
        if (session.requestReady)
            return;
        session.requestReady = true;
        if (session.pendingResize) {
            const { rows, cols } = session.pendingResize;
            session.pendingResize = null;
            this.sendPtyResizeNow(session.id, rows, cols);
        }
        if (session.pendingStdin.length > 0) {
            const pending = session.pendingStdin;
            session.pendingStdin = [];
            for (const item of pending) {
                if (item.type === "data") {
                    this.sendStdinDataNow(session.id, item.data);
                }
                else {
                    this.sendStdinEofNow(session.id);
                }
            }
        }
    }
    sendStdinData(id, data) {
        const session = this.sessions.get(id);
        if (!session)
            return;
        if (!session.requestReady) {
            session.pendingStdin.push({ type: "data", data });
            return;
        }
        this.sendStdinDataNow(id, data);
    }
    sendStdinEof(id) {
        const session = this.sessions.get(id);
        if (!session)
            return;
        if (!session.requestReady) {
            session.pendingStdin.push({ type: "eof" });
            return;
        }
        this.sendStdinEofNow(id);
    }
    sendStdinDataNow(id, data) {
        const payload = typeof data === "string" ? Buffer.from(data) : Buffer.from(data);
        for (let offset = 0; offset < payload.length; offset += DEFAULT_STDIN_CHUNK) {
            const slice = payload.subarray(offset, offset + DEFAULT_STDIN_CHUNK);
            this.sendJson({
                type: "stdin",
                id,
                data: slice.toString("base64"),
            });
        }
    }
    sendStdinEofNow(id) {
        this.sendJson({
            type: "stdin",
            id,
            eof: true,
        });
    }
    sendPtyResize(id, rows, cols) {
        if (!Number.isFinite(rows) || !Number.isFinite(cols))
            return;
        const session = this.sessions.get(id);
        if (!session)
            return;
        const safeRows = Math.max(1, Math.trunc(rows));
        const safeCols = Math.max(1, Math.trunc(cols));
        if (!session.requestReady) {
            session.pendingResize = { rows: safeRows, cols: safeCols };
            return;
        }
        this.sendPtyResizeNow(id, safeRows, safeCols);
    }
    sendPtyResizeNow(id, rows, cols) {
        if (!this.ws || this.ws.readyState !== ws_1.WebSocket.OPEN)
            return;
        this.sendJson({
            type: "pty_resize",
            id,
            rows,
            cols,
        });
    }
    async ensureConnection() {
        if (this.ws && this.ws.readyState === ws_1.WebSocket.OPEN)
            return;
        if (this.connectPromise)
            return this.connectPromise;
        if (!this.url) {
            throw new Error("WebSocket URL is not available");
        }
        this.resetConnectionState();
        this.connectPromise = new Promise((resolve, reject) => {
            const headers = {};
            if (this.token)
                headers.Authorization = `Bearer ${this.token}`;
            const ws = new ws_1.WebSocket(this.url, { headers });
            this.ws = ws;
            let opened = false;
            ws.on("open", () => {
                opened = true;
                this.flushPolicy();
                resolve();
            });
            ws.on("message", (data, isBinary) => {
                this.handleMessage(data, isBinary);
            });
            ws.on("close", () => {
                const error = new Error("WebSocket closed");
                if (!opened) {
                    reject(error);
                }
                this.handleDisconnect(error);
            });
            ws.on("error", (err) => {
                if (!opened) {
                    reject(err);
                    return;
                }
                const error = err instanceof Error ? err : new Error(String(err));
                this.handleDisconnect(error);
            });
        }).finally(() => {
            this.connectPromise = null;
        });
        return this.connectPromise;
    }
    resetConnectionState() {
        this.state = "unknown";
        this.bootSent = false;
        this.vfsReadyPromise = null;
        this.initStatusPromise();
    }
    initStatusPromise() {
        this.statusPromise = new Promise((resolve, reject) => {
            this.statusResolve = resolve;
            this.statusReject = reject;
        });
    }
    flushPolicy() {
        if (this.policy) {
            this.sendJson({ type: "policy", policy: this.policy });
        }
    }
    ensureBoot() {
        if (this.bootSent)
            return;
        this.bootSent = true;
        this.state = "unknown";
        this.initStatusPromise();
        this.sendJson({
            type: "boot",
            fuseMount: this.fuseMount,
            fuseBinds: this.fuseBinds,
        });
    }
    async ensureRunning() {
        const state = await this.waitForStatus();
        if (state === "stopped" && !this.autoStart) {
            throw new Error("sandbox is stopped");
        }
        this.ensureBoot();
        const nextState = await this.waitForStatus();
        if (nextState === "running")
            return;
        await this.waitForState("running");
    }
    async ensureVfsReady() {
        if (!this.vfs)
            return;
        if (!this.vfsReadyPromise) {
            this.vfsReadyPromise = this.waitForVfsReadyInternal().catch((error) => {
                this.vfsReadyPromise = null;
                throw error;
            });
        }
        await this.vfsReadyPromise;
    }
    async waitForVfsReadyInternal() {
        await this.waitForMount(this.fuseMount, "fuse.sandboxfs");
        for (const mountPoint of this.fuseBinds) {
            await this.waitForMount(mountPoint);
        }
    }
    async waitForMount(mountPoint, fsType) {
        const mountCheck = fsType
            ? `grep -q " $1 ${fsType} " /proc/mounts`
            : `grep -q " $1 " /proc/mounts`;
        const script = `for i in $(seq 1 ${VFS_READY_ATTEMPTS}); do ${mountCheck} && exit 0; sleep ${VFS_READY_SLEEP_SECONDS}; done; exit 1`;
        // Use internal exec that bypasses VFS check
        const result = await this.execInternalNoVfsWait(["sh", "-c", script, "sh", mountPoint]);
        if (result.exitCode !== 0) {
            throw new Error(`vfs mount ${mountPoint} not ready (exit ${result.exitCode}): ${result.stderr.trim()}`);
        }
    }
    async execInternalNoVfsWait(command) {
        const { cmd, argv } = normalizeCommand(command, {});
        const id = this.allocateId();
        const session = (0, exec_1.createExecSession)(id, {
            stdinEnabled: false,
        });
        this.sessions.set(id, session);
        const message = {
            type: "exec",
            id,
            cmd,
            argv: argv.length ? argv : undefined,
        };
        try {
            this.sendJson(message);
            this.markSessionReady(session);
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            this.sessions.delete(id);
            (0, exec_1.rejectExecSession)(session, error);
        }
        return session.resultPromise;
    }
    async waitForStatus() {
        if (this.state !== "unknown")
            return this.state;
        if (!this.statusPromise) {
            this.initStatusPromise();
        }
        return this.statusPromise;
    }
    waitForState(state) {
        if (this.state === state)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            this.stateWaiters.push({ state, resolve, reject });
        });
    }
    handleMessage(data, isBinary) {
        if (isBinary) {
            const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);
            const frame = (0, ws_protocol_1.decodeOutputFrame)(buffer);
            const session = this.sessions.get(frame.id);
            if (!session)
                return;
            if (frame.stream === "stdout") {
                if (!session.iterating) {
                    session.stdoutChunks.push(frame.data);
                }
                session.stdout.write(frame.data);
            }
            else {
                if (!session.iterating) {
                    session.stderrChunks.push(frame.data);
                }
                session.stderr.write(frame.data);
            }
            return;
        }
        let message;
        try {
            message = JSON.parse(data.toString());
        }
        catch {
            return;
        }
        if (message.type === "status") {
            this.updateState(message.state);
            return;
        }
        if (message.type === "exec_response") {
            this.handleExecResponse(message);
            return;
        }
        if (message.type === "error") {
            this.handleError(message);
        }
    }
    updateState(state) {
        this.state = state;
        if (this.statusResolve) {
            this.statusResolve(state);
            this.statusResolve = null;
            this.statusReject = null;
            this.statusPromise = null;
        }
        if (this.stateWaiters.length > 0) {
            const remaining = [];
            for (const waiter of this.stateWaiters) {
                if (waiter.state === state) {
                    waiter.resolve();
                }
                else {
                    remaining.push(waiter);
                }
            }
            this.stateWaiters = remaining;
        }
    }
    handleExecResponse(message) {
        const session = this.sessions.get(message.id);
        if (!session)
            return;
        this.sessions.delete(message.id);
        (0, exec_1.finishExecSession)(session, message.exit_code ?? 1, message.signal);
    }
    handleError(message) {
        const error = new Error(`error ${message.code}: ${message.message}`);
        if (message.id === undefined) {
            this.rejectAll(error);
            return;
        }
        const session = this.sessions.get(message.id);
        if (session) {
            this.sessions.delete(message.id);
            (0, exec_1.rejectExecSession)(session, error);
        }
    }
    rejectAll(error) {
        for (const session of this.sessions.values()) {
            (0, exec_1.rejectExecSession)(session, error);
        }
        this.sessions.clear();
    }
    handleDisconnect(error) {
        this.ws = null;
        if (this.statusReject) {
            this.statusReject(error ?? new Error("WebSocket disconnected"));
            this.statusReject = null;
            this.statusResolve = null;
            this.statusPromise = null;
        }
        if (this.stateWaiters.length > 0) {
            for (const waiter of this.stateWaiters) {
                waiter.reject(error ?? new Error("WebSocket disconnected"));
            }
            this.stateWaiters = [];
        }
        this.rejectAll(error ?? new Error("WebSocket disconnected"));
    }
    async disconnect() {
        if (!this.ws)
            return;
        const ws = this.ws;
        this.ws = null;
        if (ws.readyState === ws_1.WebSocket.CLOSED)
            return;
        await new Promise((resolve) => {
            let finished = false;
            const finish = () => {
                if (finished)
                    return;
                finished = true;
                clearTimeout(timeout);
                resolve();
            };
            const timeout = setTimeout(() => {
                ws.terminate();
                finish();
            }, 1000);
            ws.once("close", finish);
            ws.once("error", finish);
            if (ws.readyState === ws_1.WebSocket.CLOSING) {
                return;
            }
            ws.close();
        });
    }
    sendJson(message) {
        if (!this.ws || this.ws.readyState !== ws_1.WebSocket.OPEN) {
            throw new Error("WebSocket is not connected");
        }
        this.ws.send(JSON.stringify(message));
    }
}
exports.VM = VM;
function normalizeCommand(command, options) {
    if (Array.isArray(command)) {
        if (command.length === 0) {
            throw new Error("command array must include the executable");
        }
        return { cmd: command[0], argv: command.slice(1) };
    }
    return { cmd: command, argv: options.argv ?? [] };
}
function resolveVmVfs(options, injectedMounts) {
    if (options === null) {
        return { provider: null, mounts: {} };
    }
    const hooks = options?.hooks ?? {};
    const mounts = { ...(options?.mounts ?? {}) };
    if (injectedMounts) {
        for (const [mountPath, provider] of Object.entries(injectedMounts)) {
            if (!(mountPath in mounts)) {
                mounts[mountPath] = provider;
            }
        }
    }
    const mountKeys = Object.keys(mounts);
    if (mountKeys.length === 0) {
        return { provider: wrapProvider(new vfs_1.MemoryProvider(), hooks), mounts };
    }
    const normalized = (0, mounts_1.normalizeMountMap)(mounts);
    let provider;
    if (normalized.size === 1 && normalized.has("/")) {
        provider = normalized.get("/");
    }
    else {
        provider = new mounts_1.MountRouterProvider(normalized);
    }
    return { provider: wrapProvider(provider, hooks), mounts };
}
function wrapProvider(provider, hooks) {
    if (provider instanceof vfs_1.SandboxVfsProvider)
        return provider;
    return new vfs_1.SandboxVfsProvider(provider, hooks);
}
function resolveFuseConfig(options, mounts) {
    const fuseMount = (0, mounts_1.normalizeMountPath)(options?.fuseMount ?? "/data");
    const mountPaths = (0, mounts_1.listMountPaths)(mounts ?? options?.mounts);
    const fuseBinds = mountPaths.filter((mountPath) => mountPath !== "/");
    return { fuseMount, fuseBinds };
}
function resolveMitmMounts(options, mitmCertDir, netEnabled = true) {
    if (options === null || !netEnabled)
        return {};
    const mountPaths = (0, mounts_1.listMountPaths)(options?.mounts);
    if (mountPaths.includes("/etc/ssl/certs")) {
        return {};
    }
    return {
        "/etc/ssl/certs": createMitmCaProvider(mitmCertDir),
    };
}
function createMitmCaProvider(mitmCertDir) {
    const resolvedDir = (0, mitm_1.resolveMitmCertDir)(mitmCertDir);
    const ca = (0, mitm_1.loadOrCreateMitmCaSync)(resolvedDir);
    const provider = new vfs_1.MemoryProvider();
    const certPem = ca.certPem.endsWith("\n") ? ca.certPem : `${ca.certPem}\n`;
    const handle = provider.openSync("/ca-certificates.crt", "w");
    try {
        handle.writeFileSync(certPem);
    }
    finally {
        handle.closeSync();
    }
    provider.setReadOnly();
    return provider;
}
function isAsyncIterable(value) {
    return (typeof value === "object" &&
        value !== null &&
        Symbol.asyncIterator in value &&
        typeof value[Symbol.asyncIterator] === "function");
}
async function* toAsyncIterable(value) {
    if (typeof value === "string" || Buffer.isBuffer(value) || typeof value === "boolean") {
        return;
    }
    if (isAsyncIterable(value)) {
        for await (const chunk of value) {
            yield Buffer.from(chunk);
        }
        return;
    }
    if (value instanceof stream_1.Readable) {
        for await (const chunk of value) {
            yield Buffer.from(chunk);
        }
        return;
    }
    throw new Error("unsupported stdin type");
}
function buildShellEnv(baseEnv, extraEnv) {
    const envMap = mergeEnvMap(baseEnv, extraEnv);
    if (envMap.size === 0) {
        const term = resolveTermValue();
        return term ? [`TERM=${term}`] : undefined;
    }
    if (!envMap.has("TERM")) {
        const term = resolveTermValue();
        if (term)
            envMap.set("TERM", term);
    }
    return mapToEnvArray(envMap);
}
function resolveTermValue() {
    const term = process.env.TERM;
    if (!term || term === "xterm-ghostty") {
        return "xterm-256color";
    }
    return term;
}
function mergeEnvInputs(baseEnv, extraEnv) {
    const envMap = mergeEnvMap(baseEnv, extraEnv);
    return envMap.size > 0 ? mapToEnvArray(envMap) : undefined;
}
function mergeEnvMap(baseEnv, extraEnv) {
    const envMap = new Map();
    for (const [key, value] of envInputToEntries(baseEnv)) {
        envMap.set(key, value);
    }
    for (const [key, value] of envInputToEntries(extraEnv)) {
        envMap.set(key, value);
    }
    return envMap;
}
function envInputToEntries(env) {
    if (!env)
        return [];
    if (Array.isArray(env)) {
        return env.map(parseEnvEntry);
    }
    return Object.entries(env);
}
function parseEnvEntry(entry) {
    const idx = entry.indexOf("=");
    if (idx === -1)
        return [entry, ""];
    return [entry.slice(0, idx), entry.slice(idx + 1)];
}
function mapToEnvArray(envMap) {
    return Array.from(envMap.entries(), ([key, value]) => `${key}=${value}`);
}
//# sourceMappingURL=vm.js.map