import { EventEmitter } from "events";
export type UdpSendMessage = {
    key: string;
    dstIP: string;
    dstPort: number;
    srcIP: string;
    srcPort: number;
    payload: Buffer;
};
export type TcpConnectMessage = {
    key: string;
    dstIP: string;
    dstPort: number;
    srcIP: string;
    srcPort: number;
};
export type TcpSendMessage = {
    key: string;
    data: Buffer;
};
export type TcpCloseMessage = {
    key: string;
    destroy: boolean;
};
export type TcpPauseMessage = {
    key: string;
};
export type TcpResumeMessage = {
    key: string;
};
export type TcpFlowProtocol = "http" | "tls";
export type TcpFlowInfo = {
    key: string;
    srcIP: string;
    srcPort: number;
    dstIP: string;
    dstPort: number;
    protocol: TcpFlowProtocol;
    httpMethod?: string;
};
export type NetworkCallbacks = {
    onUdpSend: (message: UdpSendMessage) => void;
    onTcpConnect: (message: TcpConnectMessage) => void;
    onTcpSend: (message: TcpSendMessage) => void;
    onTcpClose: (message: TcpCloseMessage) => void;
    onTcpPause: (message: TcpPauseMessage) => void;
    onTcpResume: (message: TcpResumeMessage) => void;
};
export type NetworkStackOptions = {
    gatewayIP?: string;
    vmIP?: string;
    gatewayMac?: Buffer;
    vmMac?: Buffer;
    callbacks: NetworkCallbacks;
    allowTcpFlow?: (info: TcpFlowInfo) => boolean;
};
export declare class NetworkStack extends EventEmitter {
    gatewayIP: string;
    vmIP: string;
    gatewayMac: Buffer;
    vmMac: Buffer | null;
    private readonly callbacks;
    private readonly allowTcpFlow;
    private readonly natTable;
    private readonly MAX_FLOW_SNIFF;
    private rxBuffer;
    private txQueue;
    private txQueueSize;
    private readonly TX_BUFFER_HIGH_WATER;
    private readonly TX_BUFFER_LOW_WATER;
    private readonly txPaused;
    constructor(options: NetworkStackOptions);
    reset(): void;
    hasPendingData(): boolean;
    writeToNetwork(data: Buffer): void;
    readFromNetwork(maxLen: number): Buffer | null;
    send(payload: Buffer, proto: number): void;
    sendBroadcast(payload: Buffer, proto: number): void;
    private enqueueTx;
    receive(frame: Buffer): void;
    handleARP(packet: Buffer): void;
    handleIP(packet: Buffer): void;
    calculateChecksum(buf: Buffer): number;
    calculateUdpChecksum(payload: Buffer, srcIP: Buffer, dstIP: Buffer): number;
    handleICMP(data: Buffer, srcIP: Buffer, dstIP: Buffer): void;
    sendIP(payload: Buffer, protocol: number, srcIP: Buffer, dstIP: Buffer): void;
    private looksLikeTlsClientHello;
    private matchHttpMethodPrefix;
    private parseHttpRequestLine;
    private classifyTcpFlow;
    private rejectTcpFlow;
    handleTCP(segment: Buffer, srcIP: Buffer, dstIP: Buffer): void;
    sendTCP(dstIP: Buffer, dstPort: number, srcIP: Buffer, srcPort: number, seq: number, ack: number, flags: number, payload?: Buffer): void;
    handleUDP(segment: Buffer, srcIP: Buffer, dstIP: Buffer): void;
    handleDHCP(data: Buffer): void;
    sendDHCPReply(msgType: number, xid: number, chaddr: Buffer, flags: number): void;
    handleUdpResponse(message: {
        data: Buffer;
        srcIP: string;
        srcPort: number;
        dstIP: string;
        dstPort: number;
    }): void;
    handleTcpConnected(message: {
        key: string;
    }): void;
    handleTcpData(message: {
        key: string;
        data: Buffer;
    }): void;
    handleTcpEnd(message: {
        key: string;
    }): void;
    handleTcpError(message: {
        key: string;
    }): void;
    handleTcpClosed(message: {
        key: string;
    }): void;
}
//# sourceMappingURL=network-stack.d.ts.map