"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameReader = exports.MAX_FRAME = void 0;
exports.normalize = normalize;
exports.decodeMessage = decodeMessage;
exports.buildExecRequest = buildExecRequest;
exports.buildStdinData = buildStdinData;
exports.buildPtyResize = buildPtyResize;
exports.encodeFrame = encodeFrame;
const cbor_1 = __importDefault(require("cbor"));
exports.MAX_FRAME = 4 * 1024 * 1024;
class FrameReader {
    constructor() {
        this.buffer = Buffer.alloc(0);
        this.expectedLength = null;
    }
    push(chunk, onFrame) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        while (true) {
            if (this.expectedLength === null) {
                if (this.buffer.length < 4)
                    return;
                this.expectedLength = this.buffer.readUInt32BE(0);
                this.buffer = this.buffer.slice(4);
                if (this.expectedLength > exports.MAX_FRAME) {
                    throw new Error(`Frame too large: ${this.expectedLength}`);
                }
            }
            if (this.buffer.length < this.expectedLength)
                return;
            const frame = this.buffer.slice(0, this.expectedLength);
            this.buffer = this.buffer.slice(this.expectedLength);
            this.expectedLength = null;
            onFrame(frame);
        }
    }
}
exports.FrameReader = FrameReader;
function normalize(value) {
    if (value instanceof Map) {
        const obj = {};
        for (const [key, entry] of value.entries()) {
            obj[String(key)] = normalize(entry);
        }
        return obj;
    }
    if (Array.isArray(value)) {
        return value.map((entry) => normalize(entry));
    }
    if (value instanceof Uint8Array && !Buffer.isBuffer(value)) {
        return Buffer.from(value);
    }
    return value;
}
function decodeMessage(frame) {
    const raw = cbor_1.default.decodeFirstSync(frame);
    return normalize(raw);
}
function buildExecRequest(id, payload) {
    const cleaned = { cmd: payload.cmd };
    if (payload.argv !== undefined)
        cleaned.argv = payload.argv;
    if (payload.env !== undefined)
        cleaned.env = payload.env;
    if (payload.cwd !== undefined)
        cleaned.cwd = payload.cwd;
    if (payload.stdin !== undefined)
        cleaned.stdin = payload.stdin;
    if (payload.pty !== undefined)
        cleaned.pty = payload.pty;
    return {
        v: 1,
        t: "exec_request",
        id,
        p: cleaned,
    };
}
function buildStdinData(id, data, eof) {
    return {
        v: 1,
        t: "stdin_data",
        id,
        p: {
            data,
            ...(eof ? { eof } : {}),
        },
    };
}
function buildPtyResize(id, rows, cols) {
    return {
        v: 1,
        t: "pty_resize",
        id,
        p: {
            rows,
            cols,
        },
    };
}
function encodeFrame(message) {
    const payload = cbor_1.default.encode(message);
    const header = Buffer.alloc(4);
    header.writeUInt32BE(payload.length, 0);
    return Buffer.concat([header, payload]);
}
//# sourceMappingURL=virtio-protocol.js.map