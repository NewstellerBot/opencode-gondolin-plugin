"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureGuestAssets = ensureGuestAssets;
exports.getAssetVersion = getAssetVersion;
exports.getAssetDirectory = getAssetDirectory;
exports.hasGuestAssets = hasGuestAssets;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const fs_2 = require("fs");
const child_process_1 = require("child_process");
const GITHUB_ORG = "earendil-works";
const GITHUB_REPO = "gondolin";
let cachedAssetVersion = null;
function resolveAssetVersion() {
    if (cachedAssetVersion)
        return cachedAssetVersion;
    const possiblePackageJsons = [
        path_1.default.resolve(__dirname, "..", "package.json"), // src/ (tsx/dev) -> host/package.json
        path_1.default.resolve(__dirname, "..", "..", "package.json"), // dist/src (npm) -> package/package.json
    ];
    for (const pkgPath of possiblePackageJsons) {
        try {
            if (!fs_1.default.existsSync(pkgPath))
                continue;
            const raw = fs_1.default.readFileSync(pkgPath, "utf8");
            const pkg = JSON.parse(raw);
            if (pkg.version) {
                cachedAssetVersion = `v${pkg.version}`;
                return cachedAssetVersion;
            }
        }
        catch {
            // ignore and fall through
        }
    }
    cachedAssetVersion = "v0.0.0";
    return cachedAssetVersion;
}
/**
 * Get the platform-specific asset bundle name.
 * We build separate bundles for arm64 and x64.
 */
function getAssetBundleName() {
    const arch = process.arch === "arm64" ? "arm64" : "x64";
    return `gondolin-guest-${arch}.tar.gz`;
}
/**
 * Determine where to look for / store guest assets.
 *
 * Priority:
 * 1. GONDOLIN_GUEST_DIR environment variable (explicit override)
 * 2. Local development checkout (guest/image/out relative to package)
 * 3. User cache directory (~/.cache/gondolin/<version>)
 */
function getAssetDir() {
    // Explicit override
    if (process.env.GONDOLIN_GUEST_DIR) {
        return process.env.GONDOLIN_GUEST_DIR;
    }
    // Check for local development (repo checkout)
    // Handle both source (src/) and compiled (dist/src/) paths
    // We need to find the repo root where guest/ lives
    const possibleRepoRoots = [
        path_1.default.resolve(__dirname, "..", ".."), // from src/: -> host/ -> gondolin/
        path_1.default.resolve(__dirname, "..", "..", ".."), // from dist/src/: -> dist/ -> host/ -> gondolin/
    ];
    for (const repoRoot of possibleRepoRoots) {
        const devPath = path_1.default.join(repoRoot, "guest", "image", "out");
        if (fs_1.default.existsSync(path_1.default.join(devPath, "vmlinuz-virt"))) {
            return devPath;
        }
    }
    // User cache directory
    const cacheBase = process.env.XDG_CACHE_HOME ?? path_1.default.join(os_1.default.homedir(), ".cache");
    return path_1.default.join(cacheBase, "gondolin", resolveAssetVersion());
}
/**
 * Check if all guest assets are present in a directory.
 */
function assetsExist(dir) {
    return (fs_1.default.existsSync(path_1.default.join(dir, "vmlinuz-virt")) &&
        fs_1.default.existsSync(path_1.default.join(dir, "initramfs.cpio.lz4")) &&
        fs_1.default.existsSync(path_1.default.join(dir, "rootfs.ext4")));
}
/**
 * Download and extract the guest image bundle from GitHub releases.
 */
async function downloadAndExtract(assetDir) {
    const bundleName = getAssetBundleName();
    const assetVersion = resolveAssetVersion();
    const url = `https://github.com/${GITHUB_ORG}/${GITHUB_REPO}/releases/download/${assetVersion}/${bundleName}`;
    fs_1.default.mkdirSync(assetDir, { recursive: true });
    const tempFile = path_1.default.join(assetDir, bundleName);
    try {
        process.stderr.write(`Downloading gondolin guest image (${assetVersion})...\n`);
        process.stderr.write(`  URL: ${url}\n`);
        const response = await fetch(url, {
            headers: {
                "User-Agent": `gondolin/${assetVersion}`,
            },
        });
        if (!response.ok) {
            throw new Error(`Failed to download guest image: ${response.status} ${response.statusText}\n` +
                `URL: ${url}\n` +
                `Make sure the release exists and the asset is uploaded.`);
        }
        const contentLength = response.headers.get("content-length");
        const totalBytes = contentLength ? parseInt(contentLength, 10) : null;
        // Stream to temp file with progress
        const fileStream = (0, fs_2.createWriteStream)(tempFile);
        if (response.body) {
            let downloadedBytes = 0;
            const reader = response.body.getReader();
            while (true) {
                const { done, value } = await reader.read();
                if (done)
                    break;
                fileStream.write(Buffer.from(value));
                downloadedBytes += value.length;
                if (totalBytes) {
                    const percent = ((downloadedBytes / totalBytes) * 100).toFixed(1);
                    const mb = (downloadedBytes / 1024 / 1024).toFixed(1);
                    const totalMb = (totalBytes / 1024 / 1024).toFixed(1);
                    process.stderr.write(`\r  Progress: ${mb}/${totalMb} MB (${percent}%)`);
                }
            }
            process.stderr.write("\n");
        }
        await new Promise((resolve, reject) => {
            fileStream.end((err) => {
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
        // Extract
        process.stderr.write(`  Extracting to ${assetDir}...\n`);
        (0, child_process_1.execSync)(`tar -xzf "${bundleName}"`, { cwd: assetDir, stdio: "pipe" });
        // Verify extraction
        if (!assetsExist(assetDir)) {
            throw new Error("Extraction completed but expected files are missing. " +
                "The archive may be corrupted or have an unexpected structure.");
        }
        process.stderr.write(`  Guest image installed successfully.\n`);
    }
    finally {
        // Clean up temp file
        if (fs_1.default.existsSync(tempFile)) {
            fs_1.default.unlinkSync(tempFile);
        }
    }
}
/**
 * Ensure guest assets are available, downloading them if necessary.
 *
 * This function checks for the guest image files (kernel, initramfs, rootfs)
 * and downloads them from GitHub releases if they're not present locally.
 *
 * Asset location priority:
 * 1. GONDOLIN_GUEST_DIR environment variable
 * 2. Local development checkout (../guest/image/out)
 * 3. User cache (~/.cache/gondolin/<version>)
 *
 * @returns Paths to the guest assets
 * @throws If download fails or assets cannot be verified
 */
async function ensureGuestAssets() {
    const assetDir = getAssetDir();
    // Check if already present
    if (!assetsExist(assetDir)) {
        await downloadAndExtract(assetDir);
    }
    return {
        kernelPath: path_1.default.join(assetDir, "vmlinuz-virt"),
        initrdPath: path_1.default.join(assetDir, "initramfs.cpio.lz4"),
        rootfsPath: path_1.default.join(assetDir, "rootfs.ext4"),
    };
}
/**
 * Get the current asset version string.
 */
function getAssetVersion() {
    return resolveAssetVersion();
}
/**
 * Get the asset directory path without ensuring assets exist.
 * Useful for checking where assets would be stored.
 */
function getAssetDirectory() {
    return getAssetDir();
}
/**
 * Check if guest assets are available without downloading.
 */
function hasGuestAssets() {
    return assetsExist(getAssetDir());
}
//# sourceMappingURL=assets.js.map