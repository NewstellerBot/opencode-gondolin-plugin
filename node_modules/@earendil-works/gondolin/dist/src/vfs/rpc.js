"use strict";
/**
 * RPC client for guest FUSE filesystem operations.
 *
 * ## Protocol Conventions
 * - Paths: UTF-8, absolute, normalized with forward slashes, no trailing slash (except "/")
 * - Names: single path component (no "/" or NUL)
 * - Errors: responses include `err` (POSIX errno, 0 = success) and optional `message`
 * - Payload limit: read/write data capped at 60 KiB per request to keep frames under 64 KiB
 * - Handles: host returns opaque `fh` (u64) for open/create; guest passes back for read/write/release
 *
 * ## Caching
 * Host may provide `entry_ttl_ms` and `attr_ttl_ms` in responses. Guest caches entries
 * for the specified duration (default 1000ms). Negative lookups (ENOENT) cache for
 * `entry_ttl_ms` (default 250ms) to avoid repeated failed lookups.
 *
 * Root inode is always 1 and implicitly known at mount time.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcFsBackend = exports.RpcFileHandle = exports.FsRpcClient = void 0;
const net_1 = __importDefault(require("net"));
const path_1 = __importDefault(require("path"));
const node_fs_1 = __importDefault(require("node:fs"));
const os_1 = __importDefault(require("os"));
const cbor_1 = __importDefault(require("cbor"));
const virtio_protocol_1 = require("../virtio-protocol");
const errors_1 = require("./errors");
const node_1 = require("./node");
const { errno: ERRNO } = os_1.default.constants;
const VirtualProviderClass = node_1.VirtualProvider;
const DEFAULT_TIMEOUT_MS = 10000;
const MAX_REQUEST_ID = 0xffffffff;
const MAX_DATA_SIZE = 60 * 1024;
class FsRpcClient {
    constructor(socketPath, timeoutMs = DEFAULT_TIMEOUT_MS) {
        this.socketPath = socketPath;
        this.timeoutMs = timeoutMs;
        this.socket = null;
        this.reader = new virtio_protocol_1.FrameReader();
        this.inflight = new Map();
        this.nextId = 1;
    }
    async request(op, req) {
        const id = this.allocateId();
        const message = { v: 1, t: "fs_request", id, p: { op, req } };
        const frame = (0, virtio_protocol_1.encodeFrame)(message);
        await this.ensureSocket();
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                this.inflight.delete(id);
                reject(new Error(`fs request ${op} timed out`));
            }, this.timeoutMs);
            this.inflight.set(id, { resolve, reject, timer });
            void this.writeFrame(frame).catch((err) => {
                this.inflight.delete(id);
                if (timer)
                    clearTimeout(timer);
                reject(err instanceof Error ? err : new Error("fs write failed"));
            });
        });
    }
    requestSync(_op, _req) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "fs_request");
    }
    close() {
        if (this.socket) {
            this.socket.end();
            this.socket = null;
        }
    }
    allocateId() {
        for (let i = 0; i <= MAX_REQUEST_ID; i += 1) {
            const id = this.nextId;
            this.nextId = this.nextId + 1;
            if (this.nextId > MAX_REQUEST_ID)
                this.nextId = 1;
            if (!this.inflight.has(id))
                return id;
        }
        throw new Error("no available request ids");
    }
    async ensureSocket() {
        if (this.socket && !this.socket.destroyed)
            return;
        this.socket = net_1.default.createConnection({ path: this.socketPath });
        this.socket.on("data", (chunk) => {
            this.reader.push(chunk, (frame) => {
                try {
                    const raw = cbor_1.default.decodeFirstSync(frame);
                    const message = (0, virtio_protocol_1.normalize)(raw);
                    this.handleMessage(message);
                }
                catch (err) {
                    this.failInflight(err instanceof Error ? err : new Error("fs decode error"));
                }
            });
        });
        this.socket.on("error", (err) => {
            this.failInflight(err instanceof Error ? err : new Error("fs socket error"));
        });
        this.socket.on("close", () => {
            this.failInflight(new Error("fs socket closed"));
        });
    }
    async writeFrame(frame) {
        const socket = this.socket;
        if (!socket || socket.destroyed) {
            throw new Error("fs socket not connected");
        }
        const ok = socket.write(frame);
        if (!ok) {
            await new Promise((resolve, reject) => {
                const onError = (err) => {
                    cleanup();
                    reject(err);
                };
                const onDrain = () => {
                    cleanup();
                    resolve();
                };
                const onClose = () => {
                    cleanup();
                    reject(new Error("fs socket closed"));
                };
                const cleanup = () => {
                    socket.off("error", onError);
                    socket.off("drain", onDrain);
                    socket.off("close", onClose);
                };
                socket.once("error", onError);
                socket.once("drain", onDrain);
                socket.once("close", onClose);
            });
        }
    }
    handleMessage(message) {
        if (message.t === "error") {
            const inflight = this.inflight.get(message.id);
            if (!inflight)
                return;
            this.inflight.delete(message.id);
            if (inflight.timer)
                clearTimeout(inflight.timer);
            inflight.reject(new Error(`fs error ${message.p.code}: ${message.p.message}`));
            return;
        }
        const inflight = this.inflight.get(message.id);
        if (!inflight)
            return;
        this.inflight.delete(message.id);
        if (inflight.timer)
            clearTimeout(inflight.timer);
        inflight.resolve(message);
    }
    failInflight(error) {
        for (const [id, inflight] of this.inflight.entries()) {
            this.inflight.delete(id);
            if (inflight.timer)
                clearTimeout(inflight.timer);
            inflight.reject(error);
        }
    }
}
exports.FsRpcClient = FsRpcClient;
class RpcFileHandle {
    constructor(client, ino, fh, path, flags) {
        this.client = client;
        this.ino = ino;
        this.fh = fh;
        this.path = path;
        this.flags = flags;
        this.isClosed = false;
        this.cursor = 0;
    }
    get position() {
        return this.cursor;
    }
    set position(value) {
        this.cursor = value;
    }
    get closed() {
        return this.isClosed;
    }
    readSync(_buffer, _offset, _length, _position) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "read");
    }
    async read(buffer, offset, length, position) {
        this.ensureOpen();
        const size = Math.min(length, MAX_DATA_SIZE);
        const readOffset = position ?? this.position;
        const response = await this.client.request("read", {
            fh: this.fh,
            offset: readOffset,
            size,
        });
        assertOk(response, "read");
        const data = Buffer.from(response.p.res?.data ?? []);
        data.copy(buffer, offset);
        if (position === null || position === undefined) {
            this.position = readOffset + data.length;
        }
        return { bytesRead: data.length, buffer };
    }
    writeSync(_buffer, _offset, _length, _position) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "write");
    }
    async write(buffer, offset, length, position) {
        this.ensureOpen();
        const data = buffer.subarray(offset, offset + Math.min(length, MAX_DATA_SIZE));
        const writeOffset = position ?? this.position;
        const response = await this.client.request("write", {
            fh: this.fh,
            offset: writeOffset,
            data,
        });
        assertOk(response, "write");
        const written = response.p.res?.size ?? data.length;
        if (position === null || position === undefined) {
            this.position = writeOffset + written;
        }
        return { bytesWritten: written, buffer };
    }
    readFileSync(_options) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "readFile");
    }
    async readFile(options) {
        this.ensureOpen();
        const encoding = typeof options === "string" ? options : options?.encoding;
        let offset = 0;
        const chunks = [];
        while (true) {
            const response = await this.client.request("read", {
                fh: this.fh,
                offset,
                size: MAX_DATA_SIZE,
            });
            assertOk(response, "read");
            const data = Buffer.from(response.p.res?.data ?? []);
            if (data.length === 0)
                break;
            chunks.push(data);
            offset += data.length;
        }
        const content = Buffer.concat(chunks);
        return encoding ? content.toString(encoding) : content;
    }
    writeFileSync(_data, _options) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "writeFile");
    }
    async writeFile(data, options) {
        this.ensureOpen();
        const buffer = typeof data === "string" ? Buffer.from(data, options?.encoding) : Buffer.from(data);
        const truncateResponse = await this.client.request("truncate", { ino: this.ino, size: 0 });
        assertOk(truncateResponse, "truncate");
        let offset = 0;
        while (offset < buffer.length) {
            const slice = buffer.subarray(offset, offset + MAX_DATA_SIZE);
            const response = await this.client.request("write", {
                fh: this.fh,
                offset,
                data: slice,
            });
            assertOk(response, "write");
            const written = response.p.res?.size ?? slice.length;
            offset += written;
            if (written === 0)
                break;
        }
        this.position = buffer.length;
    }
    statSync() {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "stat");
    }
    async stat() {
        this.ensureOpen();
        const response = await this.client.request("getattr", { ino: this.ino });
        assertOk(response, "getattr");
        return statsFromAttr(response.p.res?.attr);
    }
    truncateSync(_length = 0) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "truncate");
    }
    async truncate(length) {
        this.ensureOpen();
        const response = await this.client.request("truncate", { ino: this.ino, size: length ?? 0 });
        assertOk(response, "truncate");
    }
    closeSync() {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "close");
    }
    async close() {
        if (this.isClosed)
            return;
        const response = await this.client.request("release", { fh: this.fh });
        assertOk(response, "release");
        this.isClosed = true;
    }
    ensureOpen() {
        if (this.isClosed) {
            throw (0, errors_1.createErrnoError)(ERRNO.EBADF, "read");
        }
    }
}
exports.RpcFileHandle = RpcFileHandle;
class RpcDirent {
    constructor(name, entryType, parentPath = "") {
        this.name = name;
        this.entryType = entryType;
        this.parentPath = parentPath;
        this.path = parentPath;
    }
    isFile() {
        return this.entryType === "file";
    }
    isDirectory() {
        return this.entryType === "dir";
    }
    isSymbolicLink() {
        return this.entryType === "symlink";
    }
    isBlockDevice() {
        return false;
    }
    isCharacterDevice() {
        return false;
    }
    isFIFO() {
        return false;
    }
    isSocket() {
        return false;
    }
}
class RpcFsBackend extends VirtualProviderClass {
    constructor(client) {
        super();
        this.client = client;
        this.cache = new Map();
        const now = Date.now();
        this.cache.set("/", {
            ino: 1,
            attr: {
                ino: 1,
                mode: node_fs_1.default.constants.S_IFDIR | 0o755,
                nlink: 1,
                uid: 0,
                gid: 0,
                size: 0,
                atime_ms: now,
                mtime_ms: now,
                ctime_ms: now,
            },
            expiresAt: now + 1000,
            attrExpiresAt: now + 1000,
            negative: false,
        });
    }
    get readonly() {
        return false;
    }
    get supportsSymlinks() {
        return false;
    }
    get supportsWatch() {
        return false;
    }
    openSync(_entryPath, _flags, _mode) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "open");
    }
    async open(entryPath, flags, mode) {
        const normalized = normalizePath(entryPath);
        const flagInfo = parseOpenFlags(flags);
        let entry = await this.lookupPath(normalized);
        if (!entry && flagInfo.create) {
            const { parent, name } = await this.lookupParent(normalized);
            const response = await this.client.request("create", {
                parent_ino: parent.ino,
                name,
                mode: mode ?? 0o644,
                flags: flagInfo.numeric,
            });
            assertOk(response, "create", entryPath);
            const created = response.p.res?.entry;
            entry = this.cacheEntry(normalized, created);
            const fh = response.p.res?.fh;
            return new RpcFileHandle(this.client, entry.ino, fh, normalized, flags);
        }
        if (!entry) {
            throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, "open", entryPath);
        }
        const response = await this.client.request("open", { ino: entry.ino, flags: flagInfo.numeric });
        assertOk(response, "open", entryPath);
        const fh = response.p.res?.fh;
        if (flagInfo.truncate) {
            await this.client.request("truncate", { ino: entry.ino, size: 0 });
        }
        return new RpcFileHandle(this.client, entry.ino, fh, normalized, flags);
    }
    statSync(_entryPath, _options) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "stat");
    }
    async stat(entryPath, _options) {
        const entry = await this.ensureEntry(entryPath);
        const response = await this.client.request("getattr", { ino: entry.ino });
        assertOk(response, "getattr", entryPath);
        const attr = response.p.res?.attr;
        const attrTtl = response.p.res?.attr_ttl_ms ?? 1000;
        this.updateAttr(entryPath, attr, attrTtl);
        return statsFromAttr(attr);
    }
    lstatSync(_entryPath, _options) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "lstat");
    }
    async lstat(entryPath, options) {
        return this.stat(entryPath, options);
    }
    readdirSync(_entryPath, _options) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "readdir");
    }
    async readdir(entryPath, options) {
        const entry = await this.ensureEntry(entryPath);
        const names = [];
        let offset = 0;
        while (true) {
            const response = await this.client.request("readdir", {
                ino: entry.ino,
                offset,
                max_entries: 1024,
            });
            assertOk(response, "readdir", entryPath);
            const entries = response.p.res?.entries ?? [];
            for (const dirent of entries) {
                if (options?.withFileTypes) {
                    const type = dirent.type === 2 ? "dir" : dirent.type === 10 ? "symlink" : "file";
                    names.push(new RpcDirent(dirent.name, type));
                }
                else {
                    names.push(dirent.name);
                }
            }
            const nextOffset = response.p.res?.next_offset ?? 0;
            if (!nextOffset)
                break;
            offset = nextOffset;
        }
        return names;
    }
    mkdirSync(_entryPath, _options) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "mkdir");
    }
    async mkdir(entryPath, options) {
        const normalized = normalizePath(entryPath);
        if (normalized === "/")
            return;
        if (options?.recursive) {
            await this.mkdirRecursive(normalized, options?.mode);
            return;
        }
        const { parent, name } = await this.lookupParent(normalized);
        const response = await this.client.request("mkdir", {
            parent_ino: parent.ino,
            name,
            mode: options?.mode ?? 0o755,
        });
        assertOk(response, "mkdir", entryPath);
        const entry = response.p.res?.entry;
        this.cacheEntry(normalized, entry);
    }
    rmdirSync(_entryPath) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "rmdir");
    }
    async rmdir(entryPath) {
        const normalized = normalizePath(entryPath);
        const { parent, name } = await this.lookupParent(normalized);
        const response = await this.client.request("rmdir", { parent_ino: parent.ino, name });
        assertOk(response, "rmdir", entryPath);
        this.cache.delete(normalized);
    }
    unlinkSync(_entryPath) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "unlink");
    }
    async unlink(entryPath) {
        const normalized = normalizePath(entryPath);
        const { parent, name } = await this.lookupParent(normalized);
        const response = await this.client.request("unlink", { parent_ino: parent.ino, name });
        assertOk(response, "unlink", entryPath);
        this.cache.delete(normalized);
    }
    renameSync(_oldPath, _newPath) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "rename");
    }
    async rename(oldPath, newPath) {
        const source = normalizePath(oldPath);
        const target = normalizePath(newPath);
        const oldParent = await this.lookupParent(source);
        const newParent = await this.lookupParent(target);
        const response = await this.client.request("rename", {
            old_parent_ino: oldParent.parent.ino,
            old_name: oldParent.name,
            new_parent_ino: newParent.parent.ino,
            new_name: newParent.name,
            flags: 0,
        });
        assertOk(response, "rename", oldPath);
        this.cache.delete(source);
    }
    truncateSync(_entryPath, _length) {
        // XXX: Sync RPC would deadlock the event loop; use async APIs or move RPC to a worker.
        throw (0, errors_1.createErrnoError)(ERRNO.ENOSYS, "truncate");
    }
    async truncate(entryPath, length) {
        const entry = await this.ensureEntry(entryPath);
        const response = await this.client.request("truncate", { ino: entry.ino, size: length });
        assertOk(response, "truncate", entryPath);
    }
    async lookupPath(entryPath) {
        const normalized = normalizePath(entryPath);
        if (normalized === "/") {
            return this.cache.get("/") ?? null;
        }
        const cached = this.getCached(normalized);
        if (cached) {
            return cached.negative ? null : cached;
        }
        const segments = normalized.split("/").filter(Boolean);
        let currentPath = "";
        let parent = this.cache.get("/");
        for (const segment of segments) {
            currentPath = currentPath ? `${currentPath}/${segment}` : `/${segment}`;
            const cachedEntry = this.getCached(currentPath);
            if (cachedEntry) {
                if (cachedEntry.negative) {
                    return null;
                }
                parent = cachedEntry;
                continue;
            }
            const response = await this.client.request("lookup", {
                parent_ino: parent.ino,
                name: segment,
            });
            if (response.p.err !== 0) {
                if (response.p.err === ERRNO.ENOENT) {
                    const ttl = response.p.res?.entry_ttl_ms ?? 250;
                    this.cache.set(currentPath, {
                        ino: 0,
                        attr: null,
                        expiresAt: Date.now() + ttl,
                        attrExpiresAt: 0,
                        negative: true,
                    });
                    return null;
                }
                throw (0, errors_1.createErrnoError)(response.p.err, "lookup", currentPath);
            }
            const entry = response.p.res?.entry;
            parent = this.cacheEntry(currentPath, entry);
        }
        return parent;
    }
    async lookupParent(entryPath) {
        const parentPath = path_1.default.posix.dirname(entryPath);
        const name = path_1.default.posix.basename(entryPath);
        const parent = await this.ensureEntry(parentPath);
        return { parent, name };
    }
    async ensureEntry(entryPath) {
        const entry = await this.lookupPath(entryPath);
        if (!entry) {
            throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, "stat", entryPath);
        }
        return entry;
    }
    getCached(entryPath) {
        const entry = this.cache.get(entryPath);
        if (!entry)
            return null;
        if (entry.expiresAt && entry.expiresAt < Date.now()) {
            this.cache.delete(entryPath);
            return null;
        }
        return entry;
    }
    cacheEntry(entryPath, entry) {
        const now = Date.now();
        const entryTtl = entry.entry_ttl_ms ?? 1000;
        const attrTtl = entry.attr_ttl_ms ?? 1000;
        const cached = {
            ino: entry.ino,
            attr: entry.attr,
            expiresAt: now + entryTtl,
            attrExpiresAt: now + attrTtl,
            negative: false,
        };
        this.cache.set(entryPath, cached);
        return cached;
    }
    updateAttr(entryPath, attr, ttlMs) {
        const now = Date.now();
        const cached = this.cache.get(entryPath);
        if (cached) {
            cached.attr = attr;
            cached.attrExpiresAt = now + ttlMs;
        }
    }
    async mkdirRecursive(entryPath, mode) {
        if (entryPath === "/")
            return;
        const parentPath = path_1.default.posix.dirname(entryPath);
        if (parentPath !== "/") {
            await this.mkdirRecursive(parentPath, mode);
        }
        const existing = await this.lookupPath(entryPath);
        if (existing)
            return;
        const { parent, name } = await this.lookupParent(entryPath);
        const response = await this.client.request("mkdir", {
            parent_ino: parent.ino,
            name,
            mode: mode ?? 0o755,
        });
        assertOk(response, "mkdir", entryPath);
        const entry = response.p.res?.entry;
        this.cacheEntry(entryPath, entry);
    }
}
exports.RpcFsBackend = RpcFsBackend;
function statsFromAttr(attr) {
    const stats = Object.create(node_fs_1.default.Stats.prototype);
    stats.dev = 0;
    stats.mode = attr.mode;
    stats.nlink = attr.nlink;
    stats.uid = attr.uid;
    stats.gid = attr.gid;
    stats.rdev = attr.rdev ?? 0;
    stats.blksize = attr.blksize ?? 4096;
    stats.ino = attr.ino;
    stats.size = attr.size;
    stats.blocks = attr.blocks ?? Math.ceil(attr.size / 512);
    stats.atimeMs = attr.atime_ms;
    stats.mtimeMs = attr.mtime_ms;
    stats.ctimeMs = attr.ctime_ms;
    stats.birthtimeMs = attr.ctime_ms;
    stats.atime = new Date(stats.atimeMs);
    stats.mtime = new Date(stats.mtimeMs);
    stats.ctime = new Date(stats.ctimeMs);
    stats.birthtime = new Date(stats.birthtimeMs);
    return stats;
}
function assertOk(message, syscall, entryPath) {
    if (message.p.err !== 0) {
        throw (0, errors_1.createErrnoError)(message.p.err, syscall, entryPath);
    }
}
function parseOpenFlags(flags) {
    switch (flags) {
        case "r":
            return { numeric: node_fs_1.default.constants.O_RDONLY, create: false, truncate: false };
        case "r+":
            return { numeric: node_fs_1.default.constants.O_RDWR, create: false, truncate: false };
        case "w":
            return { numeric: node_fs_1.default.constants.O_WRONLY | node_fs_1.default.constants.O_TRUNC | node_fs_1.default.constants.O_CREAT, create: true, truncate: true };
        case "w+":
            return { numeric: node_fs_1.default.constants.O_RDWR | node_fs_1.default.constants.O_TRUNC | node_fs_1.default.constants.O_CREAT, create: true, truncate: true };
        case "a":
            return { numeric: node_fs_1.default.constants.O_WRONLY | node_fs_1.default.constants.O_APPEND | node_fs_1.default.constants.O_CREAT, create: true, truncate: false };
        case "a+":
            return { numeric: node_fs_1.default.constants.O_RDWR | node_fs_1.default.constants.O_APPEND | node_fs_1.default.constants.O_CREAT, create: true, truncate: false };
        default:
            throw (0, errors_1.createErrnoError)(ERRNO.EINVAL, "open");
    }
}
function normalizePath(entryPath) {
    const normalized = path_1.default.posix.normalize(entryPath);
    if (!normalized.startsWith("/")) {
        return "/" + normalized;
    }
    return normalized === "" ? "/" : normalized;
}
//# sourceMappingURL=rpc.js.map