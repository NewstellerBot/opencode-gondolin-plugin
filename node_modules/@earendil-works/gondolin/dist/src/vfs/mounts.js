"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MountRouterProvider = void 0;
exports.normalizeMountPath = normalizeMountPath;
exports.normalizeMountMap = normalizeMountMap;
exports.listMountPaths = listMountPaths;
const node_fs_1 = __importDefault(require("node:fs"));
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const errors_1 = require("./errors");
const node_1 = require("./node");
const { errno: ERRNO } = node_os_1.default.constants;
const VirtualProviderClass = node_1.VirtualProvider;
class MountRouterProvider extends VirtualProviderClass {
    constructor(mounts) {
        super();
        const normalized = mounts instanceof Map ? mounts : normalizeMountMap(mounts);
        if (normalized.size === 0) {
            throw new Error("mounts cannot be empty");
        }
        this.mountMap = normalized;
        this.mountPaths = Array.from(normalized.keys()).sort((a, b) => b.length - a.length);
        const providers = Array.from(normalized.values());
        this.allReadonly = providers.every((provider) => provider.readonly);
        this.allSymlinks = providers.every((provider) => provider.supportsSymlinks);
        this.allWatch = providers.every((provider) => provider.supportsWatch);
    }
    get readonly() {
        return this.allReadonly;
    }
    get supportsSymlinks() {
        return this.allSymlinks;
    }
    get supportsWatch() {
        return this.allWatch;
    }
    async open(entryPath, flags, mode) {
        const mount = this.requireMount(entryPath, "open");
        return mount.provider.open(mount.relativePath, flags, mode);
    }
    openSync(entryPath, flags, mode) {
        const mount = this.requireMount(entryPath, "open");
        return mount.provider.openSync(mount.relativePath, flags, mode);
    }
    async stat(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            return mount.provider.stat(mount.relativePath, options);
        }
        this.ensureVirtualDir(entryPath, "stat");
        return createVirtualDirStats();
    }
    statSync(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            return mount.provider.statSync(mount.relativePath, options);
        }
        this.ensureVirtualDir(entryPath, "stat");
        return createVirtualDirStats();
    }
    async lstat(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            return mount.provider.lstat(mount.relativePath, options);
        }
        this.ensureVirtualDir(entryPath, "lstat");
        return createVirtualDirStats();
    }
    lstatSync(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            return mount.provider.lstatSync(mount.relativePath, options);
        }
        this.ensureVirtualDir(entryPath, "lstat");
        return createVirtualDirStats();
    }
    async readdir(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        const children = this.virtualChildren(entryPath);
        const withTypes = Boolean(options?.withFileTypes);
        if (!mount) {
            if (children.length === 0) {
                throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, "readdir", entryPath);
            }
            return formatVirtualEntries(children, withTypes);
        }
        const entries = (await mount.provider.readdir(mount.relativePath, options));
        return mergeEntries(entries, children, withTypes);
    }
    readdirSync(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        const children = this.virtualChildren(entryPath);
        const withTypes = Boolean(options?.withFileTypes);
        if (!mount) {
            if (children.length === 0) {
                throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, "readdir", entryPath);
            }
            return formatVirtualEntries(children, withTypes);
        }
        const entries = mount.provider.readdirSync(mount.relativePath, options);
        return mergeEntries(entries, children, withTypes);
    }
    async mkdir(entryPath, options) {
        const mount = this.requireMount(entryPath, "mkdir");
        return mount.provider.mkdir(mount.relativePath, options);
    }
    mkdirSync(entryPath, options) {
        const mount = this.requireMount(entryPath, "mkdir");
        return mount.provider.mkdirSync(mount.relativePath, options);
    }
    async rmdir(entryPath) {
        const mount = this.requireMount(entryPath, "rmdir");
        return mount.provider.rmdir(mount.relativePath);
    }
    rmdirSync(entryPath) {
        const mount = this.requireMount(entryPath, "rmdir");
        return mount.provider.rmdirSync(mount.relativePath);
    }
    async unlink(entryPath) {
        const mount = this.requireMount(entryPath, "unlink");
        return mount.provider.unlink(mount.relativePath);
    }
    unlinkSync(entryPath) {
        const mount = this.requireMount(entryPath, "unlink");
        return mount.provider.unlinkSync(mount.relativePath);
    }
    async rename(oldPath, newPath) {
        const resolved = this.requireSameMount(oldPath, newPath, "rename");
        return resolved.provider.rename(resolved.fromPath, resolved.toPath);
    }
    renameSync(oldPath, newPath) {
        const resolved = this.requireSameMount(oldPath, newPath, "rename");
        return resolved.provider.renameSync(resolved.fromPath, resolved.toPath);
    }
    async readlink(entryPath, options) {
        const mount = this.requireMount(entryPath, "readlink");
        if (mount.provider.readlink) {
            return mount.provider.readlink(mount.relativePath, options);
        }
        return super.readlink(mount.relativePath, options);
    }
    readlinkSync(entryPath, options) {
        const mount = this.requireMount(entryPath, "readlink");
        if (mount.provider.readlinkSync) {
            return mount.provider.readlinkSync(mount.relativePath, options);
        }
        return super.readlinkSync(mount.relativePath, options);
    }
    async symlink(target, entryPath, type) {
        const mount = this.requireMount(entryPath, "symlink");
        if (mount.provider.symlink) {
            return mount.provider.symlink(target, mount.relativePath, type);
        }
        return super.symlink(target, mount.relativePath, type);
    }
    symlinkSync(target, entryPath, type) {
        const mount = this.requireMount(entryPath, "symlink");
        if (mount.provider.symlinkSync) {
            return mount.provider.symlinkSync(target, mount.relativePath, type);
        }
        return super.symlinkSync(target, mount.relativePath, type);
    }
    async realpath(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            if (mount.provider.realpath) {
                return mount.provider.realpath(mount.relativePath, options);
            }
            return super.realpath(mount.relativePath, options);
        }
        this.ensureVirtualDir(entryPath, "realpath");
        return normalizePath(entryPath);
    }
    realpathSync(entryPath, options) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            if (mount.provider.realpathSync) {
                return mount.provider.realpathSync(mount.relativePath, options);
            }
            return super.realpathSync(mount.relativePath, options);
        }
        this.ensureVirtualDir(entryPath, "realpath");
        return normalizePath(entryPath);
    }
    async access(entryPath, mode) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            if (mount.provider.access) {
                return mount.provider.access(mount.relativePath, mode);
            }
            return super.access(mount.relativePath, mode);
        }
        this.ensureVirtualDir(entryPath, "access");
    }
    accessSync(entryPath, mode) {
        const mount = this.resolveMount(entryPath);
        if (mount) {
            if (mount.provider.accessSync) {
                return mount.provider.accessSync(mount.relativePath, mode);
            }
            return super.accessSync(mount.relativePath, mode);
        }
        this.ensureVirtualDir(entryPath, "access");
    }
    watch(entryPath, options) {
        const mount = this.requireMount(entryPath, "watch");
        if (mount.provider.watch) {
            return mount.provider.watch(mount.relativePath, options);
        }
        return super.watch(mount.relativePath, options);
    }
    watchAsync(entryPath, options) {
        const mount = this.requireMount(entryPath, "watch");
        if (mount.provider.watchAsync) {
            return mount.provider.watchAsync(mount.relativePath, options);
        }
        return super.watchAsync(mount.relativePath, options);
    }
    watchFile(entryPath, options, listener) {
        const mount = this.requireMount(entryPath, "watchFile");
        if (mount.provider.watchFile) {
            return mount.provider.watchFile(mount.relativePath, options, listener);
        }
        return super.watchFile(mount.relativePath, options);
    }
    unwatchFile(entryPath, listener) {
        const mount = this.requireMount(entryPath, "unwatchFile");
        if (mount.provider.unwatchFile) {
            return mount.provider.unwatchFile(mount.relativePath, listener);
        }
        return super.unwatchFile(mount.relativePath, listener);
    }
    resolveMount(entryPath) {
        const normalized = normalizePath(entryPath);
        for (const mountPath of this.mountPaths) {
            if (isUnderMountPoint(normalized, mountPath)) {
                const provider = this.mountMap.get(mountPath);
                return {
                    mountPath,
                    provider,
                    relativePath: getRelativePath(normalized, mountPath),
                };
            }
        }
        return null;
    }
    virtualChildren(entryPath) {
        const normalized = normalizePath(entryPath);
        const prefix = normalized === "/" ? "/" : `${normalized}/`;
        const children = new Set();
        for (const mountPath of this.mountPaths) {
            if (mountPath === normalized)
                continue;
            if (!mountPath.startsWith(prefix))
                continue;
            const remainder = mountPath.slice(prefix.length);
            const segment = remainder.split("/")[0];
            if (segment)
                children.add(segment);
        }
        return Array.from(children).sort();
    }
    ensureVirtualDir(entryPath, op) {
        if (this.virtualChildren(entryPath).length === 0) {
            throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, op, entryPath);
        }
    }
    requireMount(entryPath, op) {
        const mount = this.resolveMount(entryPath);
        if (!mount) {
            throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, op, entryPath);
        }
        return mount;
    }
    requireSameMount(oldPath, newPath, op) {
        const from = this.requireMount(oldPath, op);
        const to = this.requireMount(newPath, op);
        if (from.mountPath !== to.mountPath) {
            throw (0, errors_1.createErrnoError)(ERRNO.EXDEV, op, oldPath);
        }
        return {
            provider: from.provider,
            fromPath: from.relativePath,
            toPath: to.relativePath,
        };
    }
}
exports.MountRouterProvider = MountRouterProvider;
class VirtualDirent {
    constructor(name) {
        this.name = name;
    }
    isFile() {
        return false;
    }
    isDirectory() {
        return true;
    }
    isSymbolicLink() {
        return false;
    }
    isBlockDevice() {
        return false;
    }
    isCharacterDevice() {
        return false;
    }
    isFIFO() {
        return false;
    }
    isSocket() {
        return false;
    }
}
function createVirtualDirStats() {
    const now = Date.now();
    const stats = Object.create(node_fs_1.default.Stats.prototype);
    Object.assign(stats, {
        dev: 0,
        mode: 0o040755,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        ino: 0,
        size: 4096,
        blocks: 8,
        atimeMs: now,
        mtimeMs: now,
        ctimeMs: now,
        birthtimeMs: now,
        atime: new Date(now),
        mtime: new Date(now),
        ctime: new Date(now),
        birthtime: new Date(now),
    });
    return stats;
}
function mergeEntries(entries, children, withTypes) {
    if (children.length === 0)
        return entries;
    const childSet = new Set(children);
    const filtered = entries.filter((entry) => !childSet.has(getEntryName(entry)));
    if (!withTypes) {
        return [...filtered, ...children];
    }
    const dirents = filtered;
    for (const child of children) {
        dirents.push(new VirtualDirent(child));
    }
    return dirents;
}
function formatVirtualEntries(children, withTypes) {
    if (!withTypes)
        return children;
    return children.map((child) => new VirtualDirent(child));
}
function getEntryName(entry) {
    return typeof entry === "string" ? entry : entry.name;
}
function isUnderMountPoint(normalizedPath, mountPoint) {
    if (normalizedPath === mountPoint)
        return true;
    if (mountPoint === "/")
        return normalizedPath.startsWith("/");
    return normalizedPath.startsWith(mountPoint + "/");
}
function getRelativePath(normalizedPath, mountPoint) {
    if (normalizedPath === mountPoint)
        return "/";
    if (mountPoint === "/")
        return normalizedPath;
    return normalizedPath.slice(mountPoint.length);
}
function normalizePath(inputPath) {
    let normalized = node_path_1.default.posix.normalize(inputPath);
    if (!normalized.startsWith("/")) {
        normalized = `/${normalized}`;
    }
    if (normalized.length > 1 && normalized.endsWith("/")) {
        normalized = normalized.slice(0, -1);
    }
    return normalized;
}
function normalizeMountPath(inputPath) {
    if (typeof inputPath !== "string" || inputPath.length === 0) {
        throw new Error("mount path must be a non-empty string");
    }
    if (!inputPath.startsWith("/")) {
        throw new Error(`mount path must be absolute: ${inputPath}`);
    }
    if (inputPath.includes("\0")) {
        throw new Error("mount path contains null bytes");
    }
    return normalizePath(inputPath);
}
function normalizeMountMap(mounts) {
    const map = new Map();
    for (const [mountPath, provider] of Object.entries(mounts)) {
        if (!provider || typeof provider.open !== "function") {
            throw new Error(`mount provider for ${mountPath} is invalid`);
        }
        const normalized = normalizeMountPath(mountPath);
        if (map.has(normalized)) {
            throw new Error(`duplicate mount path: ${normalized}`);
        }
        map.set(normalized, provider);
    }
    return map;
}
function listMountPaths(mounts) {
    if (!mounts)
        return [];
    return Array.from(normalizeMountMap(mounts).keys()).sort();
}
//# sourceMappingURL=mounts.js.map