/**
 * RPC client for guest FUSE filesystem operations.
 *
 * ## Protocol Conventions
 * - Paths: UTF-8, absolute, normalized with forward slashes, no trailing slash (except "/")
 * - Names: single path component (no "/" or NUL)
 * - Errors: responses include `err` (POSIX errno, 0 = success) and optional `message`
 * - Payload limit: read/write data capped at 60 KiB per request to keep frames under 64 KiB
 * - Handles: host returns opaque `fh` (u64) for open/create; guest passes back for read/write/release
 *
 * ## Caching
 * Host may provide `entry_ttl_ms` and `attr_ttl_ms` in responses. Guest caches entries
 * for the specified duration (default 1000ms). Negative lookups (ENOENT) cache for
 * `entry_ttl_ms` (default 250ms) to avoid repeated failed lookups.
 *
 * Root inode is always 1 and implicitly known at mount time.
 */
import fs from "node:fs";
import type { Dirent, Stats } from "node:fs";
import type { VirtualProvider, VirtualFileHandle } from "./node";
declare const VirtualProviderClass: {
    new (...args: any[]): any;
};
export type FsRequestMessage = {
    v: number;
    t: "fs_request";
    id: number;
    p: {
        op: string;
        req: Record<string, unknown>;
    };
};
export type FsResponseMessage = {
    v: number;
    t: "fs_response";
    id: number;
    p: {
        op: string;
        err: number;
        res?: Record<string, unknown>;
        message?: string;
    };
};
export declare class FsRpcClient {
    private readonly socketPath;
    private readonly timeoutMs;
    private socket;
    private readonly reader;
    private readonly inflight;
    private nextId;
    constructor(socketPath: string, timeoutMs?: number);
    request(op: string, req: Record<string, unknown>): Promise<FsResponseMessage>;
    requestSync(_op: string, _req: Record<string, unknown>): FsResponseMessage;
    close(): void;
    private allocateId;
    private ensureSocket;
    private writeFrame;
    private handleMessage;
    private failInflight;
}
export declare class RpcFileHandle implements VirtualFileHandle {
    private readonly client;
    private readonly ino;
    private readonly fh;
    readonly path: string;
    readonly flags: string;
    private isClosed;
    private cursor;
    constructor(client: FsRpcClient, ino: number, fh: number, path: string, flags: string);
    get position(): number;
    set position(value: number);
    get closed(): boolean;
    readSync(_buffer: Buffer, _offset: number, _length: number, _position?: number | null): number;
    read(buffer: Buffer, offset: number, length: number, position?: number | null): Promise<{
        readonly bytesRead: number;
        readonly buffer: Buffer<ArrayBufferLike>;
    }>;
    writeSync(_buffer: Buffer, _offset: number, _length: number, _position?: number | null): number;
    write(buffer: Buffer, offset: number, length: number, position?: number | null): Promise<{
        readonly bytesWritten: number;
        readonly buffer: Buffer<ArrayBufferLike>;
    }>;
    readFileSync(_options?: {
        encoding?: BufferEncoding;
    } | BufferEncoding): Buffer | string;
    readFile(options?: {
        encoding?: BufferEncoding;
    } | BufferEncoding): Promise<string | Buffer<ArrayBuffer>>;
    writeFileSync(_data: Buffer | string, _options?: {
        encoding?: BufferEncoding;
    }): void;
    writeFile(data: Buffer | string, options?: {
        encoding?: BufferEncoding;
    }): Promise<void>;
    statSync(): Stats;
    stat(): Promise<fs.Stats>;
    truncateSync(_length?: number): void;
    truncate(length?: number): Promise<void>;
    closeSync(): void;
    close(): Promise<void>;
    private ensureOpen;
}
export declare class RpcFsBackend extends VirtualProviderClass implements VirtualProvider {
    private readonly client;
    private readonly cache;
    constructor(client: FsRpcClient);
    get readonly(): boolean;
    get supportsSymlinks(): boolean;
    get supportsWatch(): boolean;
    openSync(_entryPath: string, _flags: string, _mode?: number): VirtualFileHandle;
    open(entryPath: string, flags: string, mode?: number): Promise<RpcFileHandle>;
    statSync(_entryPath: string, _options?: object): Stats;
    stat(entryPath: string, _options?: object): Promise<fs.Stats>;
    lstatSync(_entryPath: string, _options?: object): Stats;
    lstat(entryPath: string, options?: object): Promise<fs.Stats>;
    readdirSync(_entryPath: string, _options?: {
        withFileTypes?: boolean;
    }): Array<string | Dirent>;
    readdir(entryPath: string, options?: {
        withFileTypes?: boolean;
    }): Promise<(string | fs.Dirent<string>)[]>;
    mkdirSync(_entryPath: string, _options?: {
        recursive?: boolean;
        mode?: number;
    }): void | string;
    mkdir(entryPath: string, options?: {
        recursive?: boolean;
        mode?: number;
    }): Promise<void>;
    rmdirSync(_entryPath: string): void;
    rmdir(entryPath: string): Promise<void>;
    unlinkSync(_entryPath: string): void;
    unlink(entryPath: string): Promise<void>;
    renameSync(_oldPath: string, _newPath: string): void;
    rename(oldPath: string, newPath: string): Promise<void>;
    truncateSync(_entryPath: string, _length: number): void;
    truncate(entryPath: string, length: number): Promise<void>;
    private lookupPath;
    private lookupParent;
    private ensureEntry;
    private getCached;
    private cacheEntry;
    private updateAttr;
    private mkdirRecursive;
}
export {};
//# sourceMappingURL=rpc.d.ts.map