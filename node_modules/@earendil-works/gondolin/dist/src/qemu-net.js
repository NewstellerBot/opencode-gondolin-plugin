"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QemuNetworkBackend = exports.HttpRequestBlockedError = void 0;
const events_1 = require("events");
const net_1 = __importDefault(require("net"));
const fs_1 = __importDefault(require("fs"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const dgram_1 = __importDefault(require("dgram"));
const tls_1 = __importDefault(require("tls"));
const crypto_1 = __importDefault(require("crypto"));
const dns_1 = __importDefault(require("dns"));
const stream_1 = require("stream");
const node_forge_1 = __importDefault(require("node-forge"));
const mitm_1 = require("./mitm");
const promises_2 = require("dns/promises");
const undici_1 = require("undici");
const MAX_HTTP_REDIRECTS = 10;
const network_stack_1 = require("./network-stack");
const HOP_BY_HOP_HEADERS = new Set([
    "connection",
    "keep-alive",
    "proxy-connection",
    "transfer-encoding",
    "te",
    "trailer",
    "upgrade",
]);
class GuestTlsStream extends stream_1.Duplex {
    constructor(onEncryptedWrite) {
        super();
        this.onEncryptedWrite = onEncryptedWrite;
    }
    pushEncrypted(data) {
        this.push(data);
    }
    _read() {
        // data is pushed via pushEncrypted
    }
    _write(chunk, _encoding, callback) {
        this.onEncryptedWrite(Buffer.from(chunk));
        callback();
    }
}
class HttpRequestBlockedError extends Error {
    constructor(message = "request blocked", status = 403, statusText = "Forbidden") {
        super(message);
        this.name = "HttpRequestBlockedError";
        this.status = status;
        this.statusText = statusText;
    }
}
exports.HttpRequestBlockedError = HttpRequestBlockedError;
class QemuNetworkBackend extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.options = options;
        this.server = null;
        this.socket = null;
        this.waitingDrain = false;
        this.stack = null;
        this.udpSessions = new Map();
        this.tcpSessions = new Map();
        this.caPromise = null;
        this.tlsContexts = new Map();
        this.tlsContextPromises = new Map();
        this.policy = null;
        this.policy = options.policy ?? null;
        this.mitmDir = (0, mitm_1.resolveMitmCertDir)(options.mitmCertDir);
    }
    start() {
        if (this.server)
            return;
        if (!fs_1.default.existsSync(path_1.default.dirname(this.options.socketPath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(this.options.socketPath), { recursive: true });
        }
        fs_1.default.rmSync(this.options.socketPath, { force: true });
        this.server = net_1.default.createServer((socket) => this.attachSocket(socket));
        this.server.on("error", (err) => this.emit("error", err));
        this.server.listen(this.options.socketPath);
    }
    stop() {
        this.detachSocket();
        if (this.server) {
            this.server.close();
            this.server = null;
        }
    }
    setPolicy(policy) {
        this.policy = policy;
        this.emit("policy", policy);
    }
    getPolicy() {
        return this.policy;
    }
    attachSocket(socket) {
        if (this.socket)
            this.socket.destroy();
        this.socket = socket;
        this.waitingDrain = false;
        this.resetStack();
        socket.on("data", (chunk) => {
            this.stack?.writeToNetwork(chunk);
            this.flush();
        });
        socket.on("drain", () => {
            this.waitingDrain = false;
            this.flush();
        });
        socket.on("error", (err) => {
            this.emit("error", err);
            this.detachSocket();
        });
        socket.on("close", () => {
            this.detachSocket();
        });
    }
    detachSocket() {
        if (this.socket) {
            this.socket.destroy();
            this.socket = null;
        }
        this.waitingDrain = false;
        this.cleanupSessions();
        this.stack?.reset();
    }
    resetStack() {
        this.cleanupSessions();
        this.stack = new network_stack_1.NetworkStack({
            gatewayIP: this.options.gatewayIP,
            vmIP: this.options.vmIP,
            gatewayMac: this.options.gatewayMac,
            vmMac: this.options.vmMac,
            callbacks: {
                onUdpSend: (message) => this.handleUdpSend(message),
                onTcpConnect: (message) => this.handleTcpConnect(message),
                onTcpSend: (message) => this.handleTcpSend(message),
                onTcpClose: (message) => this.handleTcpClose(message),
                onTcpPause: (message) => this.handleTcpPause(message),
                onTcpResume: (message) => this.handleTcpResume(message),
            },
            allowTcpFlow: (info) => {
                if (info.protocol !== "http" && info.protocol !== "tls") {
                    if (this.options.debug) {
                        this.emit("log", `[net] tcp blocked ${info.srcIP}:${info.srcPort} -> ${info.dstIP}:${info.dstPort} (${info.protocol})`);
                    }
                    return false;
                }
                const session = this.tcpSessions.get(info.key);
                if (session) {
                    session.protocol = info.protocol;
                    if (info.protocol === "http" || info.protocol === "tls") {
                        session.http = session.http ?? {
                            buffer: Buffer.alloc(0),
                            processing: false,
                            closed: false,
                        };
                    }
                }
                // XXX: enforce SandboxPolicy allow/deny rules for HTTP/TLS flows here.
                return true;
            },
        });
        this.stack.on("network-activity", () => this.flush());
        this.stack.on("error", (err) => this.emit("error", err));
        if (this.options.debug) {
            this.stack.on("dhcp", (state, ip) => {
                this.emit("log", `[net] dhcp ${state} ${ip}`);
            });
        }
    }
    flush() {
        if (!this.socket || this.waitingDrain || !this.stack)
            return;
        while (this.stack.hasPendingData()) {
            const chunk = this.stack.readFromNetwork(64 * 1024);
            if (!chunk || chunk.length === 0)
                break;
            if (this.options.debug) {
                this.emit("log", `[net] tx ${chunk.length} bytes to qemu`);
            }
            const ok = this.socket.write(chunk);
            if (!ok) {
                this.waitingDrain = true;
                return;
            }
        }
    }
    cleanupSessions() {
        for (const session of this.udpSessions.values()) {
            try {
                session.socket.close();
            }
            catch {
                // ignore
            }
        }
        this.udpSessions.clear();
        for (const session of this.tcpSessions.values()) {
            try {
                session.socket?.destroy();
            }
            catch {
                // ignore
            }
        }
        this.tcpSessions.clear();
    }
    handleUdpSend(message) {
        // XXX: apply SandboxPolicy allow/deny rules for DNS/UDP destinations here.
        if (message.dstPort !== 53) {
            if (this.options.debug) {
                this.emit("log", `[net] udp blocked ${message.srcIP}:${message.srcPort} -> ${message.dstIP}:${message.dstPort}`);
            }
            return;
        }
        let session = this.udpSessions.get(message.key);
        if (!session) {
            const socket = dgram_1.default.createSocket("udp4");
            session = {
                socket,
                srcIP: message.srcIP,
                srcPort: message.srcPort,
                dstIP: message.dstIP,
                dstPort: message.dstPort,
            };
            this.udpSessions.set(message.key, session);
            socket.on("message", (data, rinfo) => {
                if (this.options.debug) {
                    this.emit("log", `[net] udp recv ${rinfo.address}:${rinfo.port} -> ${session.srcIP}:${session.srcPort} (${data.length} bytes)`);
                }
                this.stack?.handleUdpResponse({
                    data: Buffer.from(data),
                    srcIP: session.srcIP,
                    srcPort: session.srcPort,
                    dstIP: session.dstIP,
                    dstPort: session.dstPort,
                });
                this.flush();
            });
            socket.on("error", (err) => {
                this.emit("error", err);
            });
        }
        if (this.options.debug) {
            this.emit("log", `[net] udp send ${message.srcIP}:${message.srcPort} -> ${message.dstIP}:${message.dstPort} (${message.payload.length} bytes)`);
        }
        session.socket.send(message.payload, message.dstPort, message.dstIP);
    }
    handleTcpConnect(message) {
        const connectIP = message.dstIP === (this.options.gatewayIP ?? "192.168.127.1") ? "127.0.0.1" : message.dstIP;
        const session = {
            socket: null,
            srcIP: message.srcIP,
            srcPort: message.srcPort,
            dstIP: message.dstIP,
            dstPort: message.dstPort,
            connectIP,
            flowControlPaused: false,
            protocol: null,
            connected: false,
            pendingWrites: [],
        };
        this.tcpSessions.set(message.key, session);
        this.stack?.handleTcpConnected({ key: message.key });
        this.flush();
    }
    handleTcpSend(message) {
        const session = this.tcpSessions.get(message.key);
        if (!session)
            return;
        if (session.protocol === "http") {
            this.handlePlainHttpData(message.key, session, message.data);
            return;
        }
        if (session.protocol === "tls") {
            this.handleTlsData(message.key, session, message.data);
            return;
        }
        this.ensureTcpSocket(message.key, session);
        if (session.socket && session.connected && session.socket.writable) {
            session.socket.write(message.data);
        }
        else {
            session.pendingWrites.push(message.data);
        }
    }
    handleTcpClose(message) {
        const session = this.tcpSessions.get(message.key);
        if (session) {
            session.http = undefined;
            if (session.tls) {
                if (message.destroy) {
                    session.tls.socket.destroy();
                }
                else {
                    session.tls.socket.end();
                }
                session.tls = undefined;
            }
            if (session.socket) {
                if (message.destroy) {
                    session.socket.destroy();
                }
                else {
                    session.socket.end();
                }
            }
            else {
                this.tcpSessions.delete(message.key);
            }
        }
    }
    handleTcpPause(message) {
        const session = this.tcpSessions.get(message.key);
        if (session && session.socket) {
            session.flowControlPaused = true;
            session.socket.pause();
        }
    }
    handleTcpResume(message) {
        const session = this.tcpSessions.get(message.key);
        if (session && session.socket) {
            session.flowControlPaused = false;
            session.socket.resume();
        }
    }
    ensureTcpSocket(key, session) {
        if (session.socket)
            return;
        const socket = new net_1.default.Socket();
        session.socket = socket;
        socket.connect(session.dstPort, session.connectIP, () => {
            session.connected = true;
            for (const pending of session.pendingWrites) {
                socket.write(pending);
            }
            session.pendingWrites = [];
        });
        socket.on("data", (data) => {
            this.stack?.handleTcpData({ key, data: Buffer.from(data) });
            this.flush();
        });
        socket.on("end", () => {
            this.stack?.handleTcpEnd({ key });
            this.flush();
        });
        socket.on("close", () => {
            this.stack?.handleTcpClosed({ key });
            this.tcpSessions.delete(key);
        });
        socket.on("error", () => {
            this.stack?.handleTcpError({ key });
            this.tcpSessions.delete(key);
        });
    }
    ensureTlsSession(key, session) {
        if (session.tls)
            return session.tls;
        const stream = new GuestTlsStream((chunk) => {
            this.stack?.handleTcpData({ key, data: chunk });
            this.flush();
        });
        const tlsSocket = new tls_1.default.TLSSocket(stream, {
            isServer: true,
            ALPNProtocols: ["http/1.1"],
            SNICallback: (servername, callback) => {
                const sni = servername || session.dstIP;
                this.getTlsContextAsync(sni)
                    .then((context) => {
                    if (this.options.debug) {
                        this.emit("log", `[net] tls sni ${sni}`);
                    }
                    callback(null, context);
                })
                    .catch((err) => {
                    callback(err);
                });
            },
        });
        tlsSocket.on("data", (data) => {
            this.handleTlsHttpData(key, session, Buffer.from(data));
        });
        tlsSocket.on("error", (err) => {
            this.emit("error", err);
            this.stack?.handleTcpError({ key });
        });
        tlsSocket.on("close", () => {
            this.stack?.handleTcpClosed({ key });
            this.tcpSessions.delete(key);
        });
        session.tls = {
            stream,
            socket: tlsSocket,
            servername: null,
        };
        if (this.options.debug) {
            this.emit("log", `[net] tls mitm start ${session.dstIP}:${session.dstPort}`);
        }
        return session.tls;
    }
    async handlePlainHttpData(key, session, data) {
        await this.handleHttpDataWithWriter(key, session, data, {
            scheme: "http",
            write: (chunk) => {
                this.stack?.handleTcpData({ key, data: chunk });
            },
            finish: () => {
                this.stack?.handleTcpEnd({ key });
                this.flush();
            },
        });
    }
    async handleTlsHttpData(key, session, data) {
        const tlsSession = session.tls;
        if (!tlsSession)
            return;
        await this.handleHttpDataWithWriter(key, session, data, {
            scheme: "https",
            write: (chunk) => {
                tlsSession.socket.write(chunk);
            },
            finish: () => {
                tlsSession.socket.end(() => {
                    this.stack?.handleTcpEnd({ key });
                    this.flush();
                });
            },
        });
    }
    async handleHttpDataWithWriter(key, session, data, options) {
        const httpSession = session.http ?? {
            buffer: Buffer.alloc(0),
            processing: false,
            closed: false,
        };
        session.http = httpSession;
        if (httpSession.closed)
            return;
        httpSession.buffer = Buffer.concat([httpSession.buffer, data]);
        if (httpSession.processing)
            return;
        const parsed = this.parseHttpRequest(httpSession.buffer);
        if (!parsed)
            return;
        httpSession.processing = true;
        httpSession.buffer = parsed.remaining;
        try {
            await this.fetchAndRespond(parsed.request, options.scheme, options.write);
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            if (error instanceof HttpRequestBlockedError) {
                if (this.options.debug) {
                    this.emit("log", `[net] http blocked ${error.message}`);
                }
                this.respondWithError(options.write, error.status, error.statusText);
            }
            else {
                this.emit("error", error);
                this.respondWithError(options.write, 502, "Bad Gateway");
            }
        }
        finally {
            httpSession.closed = true;
            options.finish();
            this.flush();
        }
    }
    handleTlsData(key, session, data) {
        const tlsSession = this.ensureTlsSession(key, session);
        if (!tlsSession)
            return;
        tlsSession.stream.pushEncrypted(data);
    }
    parseHttpRequest(buffer) {
        const headerEnd = buffer.indexOf("\r\n\r\n");
        if (headerEnd === -1)
            return null;
        const headerBlock = buffer.subarray(0, headerEnd).toString("utf8");
        const lines = headerBlock.split("\r\n");
        if (lines.length === 0)
            return null;
        const [method, target, version] = lines[0].split(" ");
        if (!method || !target || !version)
            return null;
        const headers = {};
        for (let i = 1; i < lines.length; i += 1) {
            const line = lines[i];
            const idx = line.indexOf(":");
            if (idx === -1)
                continue;
            const key = line.slice(0, idx).trim().toLowerCase();
            const value = line.slice(idx + 1).trim();
            if (!key)
                continue;
            if (headers[key]) {
                headers[key] = `${headers[key]}, ${value}`;
            }
            else {
                headers[key] = value;
            }
        }
        const bodyOffset = headerEnd + 4;
        const bodyBuffer = buffer.subarray(bodyOffset);
        // XXX: cap request body size to avoid unbounded buffering (Content-Length/chunked).
        const transferEncoding = headers["transfer-encoding"]?.toLowerCase();
        if (transferEncoding === "chunked") {
            const chunked = this.decodeChunkedBody(bodyBuffer);
            if (!chunked.complete)
                return null;
            return {
                request: {
                    method,
                    target,
                    version,
                    headers,
                    body: chunked.body,
                },
                remaining: bodyBuffer.subarray(chunked.bytesConsumed),
            };
        }
        const contentLength = headers["content-length"] ? Number(headers["content-length"]) : 0;
        if (!Number.isFinite(contentLength) || contentLength < 0)
            return null;
        if (bodyBuffer.length < contentLength)
            return null;
        return {
            request: {
                method,
                target,
                version,
                headers,
                body: bodyBuffer.subarray(0, contentLength),
            },
            remaining: bodyBuffer.subarray(contentLength),
        };
    }
    decodeChunkedBody(buffer) {
        let offset = 0;
        const chunks = [];
        // XXX: enforce a max chunked body size while accumulating chunks.
        while (true) {
            const lineEnd = buffer.indexOf("\r\n", offset);
            if (lineEnd === -1)
                return { complete: false, body: Buffer.alloc(0), bytesConsumed: 0 };
            const sizeLine = buffer.subarray(offset, lineEnd).toString("ascii").split(";")[0].trim();
            const size = parseInt(sizeLine, 16);
            if (!Number.isFinite(size))
                return { complete: false, body: Buffer.alloc(0), bytesConsumed: 0 };
            const chunkStart = lineEnd + 2;
            const chunkEnd = chunkStart + size;
            if (buffer.length < chunkEnd + 2)
                return { complete: false, body: Buffer.alloc(0), bytesConsumed: 0 };
            if (size > 0) {
                chunks.push(buffer.subarray(chunkStart, chunkEnd));
            }
            if (buffer[chunkEnd] !== 0x0d || buffer[chunkEnd + 1] !== 0x0a) {
                return { complete: false, body: Buffer.alloc(0), bytesConsumed: 0 };
            }
            offset = chunkEnd + 2;
            if (size === 0) {
                return { complete: true, body: Buffer.concat(chunks), bytesConsumed: offset };
            }
        }
    }
    async fetchAndRespond(request, defaultScheme, write) {
        const url = this.buildFetchUrl(request, defaultScheme);
        if (!url) {
            this.respondWithError(write, 400, "Bad Request");
            return;
        }
        // XXX: validate URL + DNS/IP to block localhost/private ranges before fetch().
        if (this.options.debug) {
            this.emit("log", `[net] http bridge ${request.method} ${url}`);
        }
        let hookRequest = {
            method: request.method,
            url,
            headers: this.stripHopByHopHeaders(request.headers),
            body: request.body.length > 0 ? request.body : null,
        };
        const fetcher = this.options.fetch ?? undici_1.fetch;
        let pendingRequest = hookRequest;
        for (let redirectCount = 0; redirectCount <= MAX_HTTP_REDIRECTS; redirectCount += 1) {
            const currentRequest = await this.applyRequestHooks(pendingRequest);
            let currentUrl;
            try {
                currentUrl = new URL(currentRequest.url);
            }
            catch {
                this.respondWithError(write, 400, "Bad Request");
                return;
            }
            const protocol = getUrlProtocol(currentUrl);
            if (!protocol) {
                this.respondWithError(write, 400, "Bad Request");
                return;
            }
            const port = getUrlPort(currentUrl, protocol);
            if (!Number.isFinite(port) || port <= 0) {
                this.respondWithError(write, 400, "Bad Request");
                return;
            }
            await this.ensureRequestAllowed(currentUrl, protocol, port);
            const useDefaultFetch = this.options.fetch === undefined;
            // The custom dispatcher re-checks isAllowed against the resolved IP to
            // prevent DNS rebinding from bypassing internal range policies.
            const dispatcher = useDefaultFetch
                ? this.createCheckedDispatcher({
                    hostname: currentUrl.hostname,
                    port,
                    protocol,
                })
                : null;
            try {
                const response = await fetcher(currentUrl.toString(), {
                    method: currentRequest.method,
                    headers: currentRequest.headers,
                    body: currentRequest.body ? new Uint8Array(currentRequest.body) : undefined,
                    redirect: "manual",
                    ...(dispatcher ? { dispatcher } : {}),
                });
                const redirectUrl = getRedirectUrl(response, currentUrl);
                if (redirectUrl) {
                    if (response.body) {
                        await response.body.cancel();
                    }
                    if (redirectCount >= MAX_HTTP_REDIRECTS) {
                        throw new HttpRequestBlockedError("too many redirects", 508, "Loop Detected");
                    }
                    pendingRequest = applyRedirectRequest(pendingRequest, response.status, redirectUrl);
                    continue;
                }
                if (this.options.debug) {
                    this.emit("log", `[net] http bridge response ${response.status} ${response.statusText}`);
                }
                let responseHeaders = this.stripHopByHopHeaders(this.headersToRecord(response.headers));
                const contentEncoding = responseHeaders["content-encoding"];
                const contentLength = responseHeaders["content-length"];
                const parsedLength = contentLength ? Number(contentLength) : null;
                const hasValidLength = parsedLength !== null && Number.isFinite(parsedLength) && parsedLength >= 0;
                if (contentEncoding) {
                    delete responseHeaders["content-encoding"];
                    delete responseHeaders["content-length"];
                }
                responseHeaders["connection"] = "close";
                const responseBodyStream = response.body;
                const canStream = Boolean(responseBodyStream) && !this.options.httpHooks?.onResponse;
                if (canStream && responseBodyStream) {
                    if (contentEncoding || !hasValidLength) {
                        delete responseHeaders["content-length"];
                        responseHeaders["transfer-encoding"] = "chunked";
                        this.sendHttpResponseHead(write, {
                            status: response.status,
                            statusText: response.statusText || "OK",
                            headers: responseHeaders,
                        });
                        await this.sendChunkedBody(responseBodyStream, write);
                    }
                    else {
                        responseHeaders["content-length"] = parsedLength.toString();
                        this.sendHttpResponseHead(write, {
                            status: response.status,
                            statusText: response.statusText || "OK",
                            headers: responseHeaders,
                        });
                        await this.sendStreamBody(responseBodyStream, write);
                    }
                    return;
                }
                const responseBody = Buffer.from(await response.arrayBuffer());
                responseHeaders["content-length"] = responseBody.length.toString();
                let hookResponse = {
                    status: response.status,
                    statusText: response.statusText || "OK",
                    headers: responseHeaders,
                    body: responseBody,
                };
                if (this.options.httpHooks?.onResponse) {
                    const updated = await this.options.httpHooks.onResponse(hookResponse, currentRequest);
                    if (updated)
                        hookResponse = updated;
                }
                this.sendHttpResponse(write, hookResponse);
                return;
            }
            finally {
                if (dispatcher) {
                    dispatcher.close();
                }
            }
        }
    }
    sendHttpResponseHead(write, response) {
        const statusLine = `HTTP/1.1 ${response.status} ${response.statusText}\r\n`;
        const headers = Object.entries(response.headers)
            .map(([name, value]) => `${name}: ${value}`)
            .join("\r\n");
        const headerBlock = `${statusLine}${headers}\r\n\r\n`;
        write(Buffer.from(headerBlock));
    }
    sendHttpResponse(write, response) {
        this.sendHttpResponseHead(write, response);
        if (response.body.length > 0) {
            write(response.body);
        }
    }
    async sendChunkedBody(body, write) {
        const reader = body.getReader();
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done)
                    break;
                if (!value || value.length === 0)
                    continue;
                const sizeLine = Buffer.from(`${value.length.toString(16)}\r\n`);
                write(sizeLine);
                write(Buffer.from(value));
                write(Buffer.from("\r\n"));
            }
        }
        finally {
            reader.releaseLock();
        }
        write(Buffer.from("0\r\n\r\n"));
    }
    async sendStreamBody(body, write) {
        const reader = body.getReader();
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done)
                    break;
                if (!value || value.length === 0)
                    continue;
                write(Buffer.from(value));
            }
        }
        finally {
            reader.releaseLock();
        }
    }
    respondWithError(write, status, statusText) {
        const body = Buffer.from(`${status} ${statusText}\n`);
        this.sendHttpResponse(write, {
            status,
            statusText,
            headers: {
                "content-length": body.length.toString(),
                "content-type": "text/plain",
                connection: "close",
            },
            body,
        });
    }
    buildFetchUrl(request, defaultScheme) {
        if (request.target.startsWith("http://") || request.target.startsWith("https://")) {
            return request.target;
        }
        const host = request.headers["host"];
        if (!host)
            return null;
        return `${defaultScheme}://${host}${request.target}`;
    }
    async resolveHostname(hostname) {
        const ipFamily = net_1.default.isIP(hostname);
        if (ipFamily === 4 || ipFamily === 6) {
            return { address: hostname, family: ipFamily };
        }
        const result = await (0, promises_2.lookup)(hostname);
        return { address: result.address, family: result.family };
    }
    async ensureRequestAllowed(parsedUrl, protocol, port) {
        if (!this.options.httpHooks?.isAllowed)
            return;
        const { address, family } = await this.resolveHostname(parsedUrl.hostname);
        const allowed = await this.options.httpHooks.isAllowed({
            hostname: parsedUrl.hostname,
            ip: address,
            family,
            port,
            protocol,
        });
        if (!allowed) {
            throw new HttpRequestBlockedError(`blocked by policy: ${parsedUrl.hostname}`);
        }
    }
    async applyRequestHooks(request) {
        if (!this.options.httpHooks?.onRequest) {
            return request;
        }
        const cloned = {
            method: request.method,
            url: request.url,
            headers: { ...request.headers },
            body: request.body,
        };
        const updated = await this.options.httpHooks.onRequest(cloned);
        return updated ?? cloned;
    }
    createCheckedDispatcher(info) {
        const isAllowed = this.options.httpHooks?.isAllowed;
        if (!isAllowed)
            return null;
        const lookupFn = createLookupGuard(info, isAllowed);
        return new undici_1.Agent({ connect: { lookup: lookupFn } });
    }
    getMitmDir() {
        return this.mitmDir;
    }
    async ensureCaAsync() {
        if (this.caPromise)
            return this.caPromise;
        this.caPromise = this.loadOrCreateCa();
        return this.caPromise;
    }
    async loadOrCreateCa() {
        const mitmDir = this.getMitmDir();
        const ca = await (0, mitm_1.loadOrCreateMitmCa)(mitmDir);
        return {
            key: ca.key,
            cert: ca.cert,
            certPem: ca.certPem,
        };
    }
    async getTlsContextAsync(servername) {
        const normalized = servername.trim() || "unknown";
        // Return cached context if available
        const cached = this.tlsContexts.get(normalized);
        if (cached)
            return cached;
        // Return pending promise if already loading
        const pending = this.tlsContextPromises.get(normalized);
        if (pending)
            return pending;
        // Start loading and cache the promise
        const promise = this.createTlsContext(normalized);
        this.tlsContextPromises.set(normalized, promise);
        try {
            const context = await promise;
            this.tlsContexts.set(normalized, context);
            return context;
        }
        finally {
            this.tlsContextPromises.delete(normalized);
        }
    }
    async createTlsContext(servername) {
        const ca = await this.ensureCaAsync();
        const { keyPem, certPem } = await this.ensureLeafCertificateAsync(servername, ca);
        return tls_1.default.createSecureContext({
            key: keyPem,
            cert: `${certPem}\n${ca.certPem}`,
        });
    }
    async ensureLeafCertificateAsync(servername, ca) {
        const hostsDir = path_1.default.join(this.getMitmDir(), "hosts");
        await promises_1.default.mkdir(hostsDir, { recursive: true });
        const hash = crypto_1.default.createHash("sha256").update(servername).digest("hex").slice(0, 12);
        const slug = servername.replace(/[^a-zA-Z0-9.-]/g, "_");
        const baseName = `${slug || "host"}-${hash}`;
        const keyPath = path_1.default.join(hostsDir, `${baseName}.key`);
        const certPath = path_1.default.join(hostsDir, `${baseName}.crt`);
        try {
            // Try to load existing cert
            const [keyPem, certPem] = await Promise.all([
                promises_1.default.readFile(keyPath, "utf8"),
                promises_1.default.readFile(certPath, "utf8"),
            ]);
            return { keyPem, certPem };
        }
        catch {
            // Generate new leaf certificate
            const keys = node_forge_1.default.pki.rsa.generateKeyPair(2048);
            const cert = node_forge_1.default.pki.createCertificate();
            cert.publicKey = keys.publicKey;
            cert.serialNumber = generateSerialNumber();
            const now = new Date(Date.now() - 5 * 60 * 1000);
            cert.validity.notBefore = now;
            cert.validity.notAfter = new Date(now);
            cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + 825);
            const safeName = servername.replace(/[\r\n]/g, "");
            const attrs = [{ name: "commonName", value: safeName }];
            cert.setSubject(attrs);
            cert.setIssuer(ca.cert.subject.attributes);
            const altNames = net_1.default.isIP(servername)
                ? [{ type: 7, ip: servername }]
                : [{ type: 2, value: servername }];
            cert.setExtensions([
                { name: "basicConstraints", cA: false },
                {
                    name: "keyUsage",
                    digitalSignature: true,
                    keyEncipherment: true,
                },
                { name: "extKeyUsage", serverAuth: true },
                { name: "subjectAltName", altNames },
            ]);
            cert.sign(ca.key, node_forge_1.default.md.sha256.create());
            const keyPem = node_forge_1.default.pki.privateKeyToPem(keys.privateKey);
            const certPem = node_forge_1.default.pki.certificateToPem(cert);
            await Promise.all([
                promises_1.default.writeFile(keyPath, keyPem),
                promises_1.default.writeFile(certPath, certPem),
            ]);
            return { keyPem, certPem };
        }
    }
    stripHopByHopHeaders(headers) {
        const output = {};
        for (const [name, value] of Object.entries(headers)) {
            if (!HOP_BY_HOP_HEADERS.has(name.toLowerCase())) {
                output[name.toLowerCase()] = value;
            }
        }
        return output;
    }
    headersToRecord(headers) {
        const record = {};
        headers.forEach((value, key) => {
            record[key.toLowerCase()] = value;
        });
        return record;
    }
}
exports.QemuNetworkBackend = QemuNetworkBackend;
function createLookupGuard(info, isAllowed) {
    return (hostname, options, callback) => {
        const normalizedOptions = normalizeLookupOptions(options);
        dns_1.default.lookup(hostname, normalizedOptions, (err, address, family) => {
            if (err) {
                callback(err, normalizeLookupFailure(normalizedOptions));
                return;
            }
            void (async () => {
                const entries = normalizeLookupEntries(address, family);
                if (entries.length === 0) {
                    callback(new Error("DNS lookup returned no addresses"), normalizeLookupFailure(normalizedOptions));
                    return;
                }
                const allowedEntries = [];
                for (const entry of entries) {
                    const allowed = await isAllowed({
                        hostname: info.hostname,
                        ip: entry.address,
                        family: entry.family,
                        port: info.port,
                        protocol: info.protocol,
                    });
                    if (allowed) {
                        if (!normalizedOptions.all) {
                            callback(null, entry.address, entry.family);
                            return;
                        }
                        allowedEntries.push(entry);
                    }
                }
                if (normalizedOptions.all && allowedEntries.length > 0) {
                    callback(null, allowedEntries.map((entry) => ({
                        address: entry.address,
                        family: entry.family,
                    })));
                    return;
                }
                callback(new HttpRequestBlockedError(`blocked by policy: ${info.hostname}`), normalizeLookupFailure(normalizedOptions));
            })().catch((error) => {
                callback(error, normalizeLookupFailure(normalizedOptions));
            });
        });
    };
}
function normalizeLookupEntries(address, family) {
    if (!address)
        return [];
    if (Array.isArray(address)) {
        return address
            .map((entry) => {
            const family = entry.family === 6 ? 6 : 4;
            return {
                address: entry.address,
                family: family,
            };
        })
            .filter((entry) => Boolean(entry.address));
    }
    const resolvedFamily = family === 6 || family === 4 ? family : net_1.default.isIP(address);
    if (resolvedFamily !== 4 && resolvedFamily !== 6)
        return [];
    return [{ address, family: resolvedFamily }];
}
function normalizeLookupOptions(options) {
    if (typeof options === "number") {
        return { family: options };
    }
    return options;
}
function normalizeLookupFailure(options) {
    return options.all ? [] : "";
}
function generateSerialNumber() {
    return crypto_1.default.randomBytes(16).toString("hex");
}
function getUrlProtocol(url) {
    if (url.protocol === "https:")
        return "https";
    if (url.protocol === "http:")
        return "http";
    return null;
}
function getUrlPort(url, protocol) {
    if (url.port)
        return Number(url.port);
    return protocol === "https" ? 443 : 80;
}
function getRedirectUrl(response, currentUrl) {
    if (![301, 302, 303, 307, 308].includes(response.status))
        return null;
    const location = response.headers.get("location");
    if (!location)
        return null;
    try {
        return new URL(location, currentUrl);
    }
    catch {
        return null;
    }
}
function applyRedirectRequest(request, status, redirectUrl) {
    let method = request.method;
    let body = request.body;
    if (status === 303 && method !== "GET" && method !== "HEAD") {
        method = "GET";
        body = null;
    }
    else if ((status === 301 || status === 302) && method === "POST") {
        method = "GET";
        body = null;
    }
    const headers = { ...request.headers };
    if (headers.host) {
        headers.host = redirectUrl.host;
    }
    if (!body || method === "GET" || method === "HEAD") {
        delete headers["content-length"];
        delete headers["content-type"];
        delete headers["transfer-encoding"];
    }
    return {
        method,
        url: redirectUrl.toString(),
        headers,
        body,
    };
}
//# sourceMappingURL=qemu-net.js.map