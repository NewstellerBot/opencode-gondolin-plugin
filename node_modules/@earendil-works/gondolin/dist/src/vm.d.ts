import { SandboxPolicy } from "./ws-protocol";
import { SandboxWsServerOptions, type ResolvedServerOptions } from "./sandbox-ws-server";
import type { SandboxState } from "./sandbox-controller";
import type { HttpFetch, HttpHooks } from "./qemu-net";
import { SandboxVfsProvider, VirtualProvider, type VfsHooks } from "./vfs";
import { ExecProcess, ExecOptions } from "./exec";
type ExecInput = string | string[];
type EnvInput = string[] | Record<string, string>;
export type VmVfsOptions = {
    mounts?: Record<string, VirtualProvider>;
    hooks?: VfsHooks;
    fuseMount?: string;
};
export type VMOptions = {
    url?: string;
    token?: string;
    server?: SandboxWsServerOptions;
    policy?: SandboxPolicy;
    autoStart?: boolean;
    fetch?: HttpFetch;
    httpHooks?: HttpHooks;
    vfs?: VmVfsOptions | null;
    env?: EnvInput;
    /** Maximum memory for the VM (e.g., "1G", "512M"). Default: "1G" */
    memory?: string;
    /** Number of CPU cores for the VM. Default: 2 */
    cpus?: number;
};
export type ShellOptions = {
    /** Command to run (default: bash) */
    command?: string | string[];
    /** Environment variables */
    env?: EnvInput;
    /** Working directory */
    cwd?: string;
    /** Abort signal */
    signal?: AbortSignal;
    /**
     * Auto-attach to process stdin/stdout/stderr.
     * Default: true when running in a TTY
     */
    attach?: boolean;
};
export { ExecProcess, ExecResult, ExecOptions } from "./exec";
export type VMState = SandboxState | "unknown";
export declare class VM {
    private readonly token?;
    private readonly autoStart;
    private server;
    private readonly defaultEnv;
    private url;
    private resolvedServerOptions;
    private ws;
    private connectPromise;
    private startPromise;
    private stopPromise;
    private statusPromise;
    private statusResolve;
    private statusReject;
    private state;
    private stateWaiters;
    private sessions;
    private nextId;
    private policy;
    private vfs;
    private readonly fuseMount;
    private readonly fuseBinds;
    private bootSent;
    private vfsReadyPromise;
    /**
     * Create a VM instance, downloading guest assets if needed.
     *
     * This is the recommended way to create a VM in production, as it will
     * automatically download the guest image if it's not available locally.
     *
     * @param options VM configuration options
     * @returns A configured VM instance
     */
    static create(options?: VMOptions): Promise<VM>;
    /**
     * Create a VM instance synchronously.
     *
     * This constructor requires that guest assets are available locally (either
     * in a development checkout or via GONDOLIN_GUEST_DIR). For automatic asset
     * downloading, use the async `VM.create()` factory instead.
     *
     * @param options VM configuration options
     * @param resolvedServerOptions Optional pre-resolved server options (from VM.create())
     */
    constructor(options?: VMOptions, resolvedServerOptions?: ResolvedServerOptions);
    getState(): "unknown" | SandboxState;
    getUrl(): string | null;
    getPolicy(): SandboxPolicy | null;
    getVfs(): SandboxVfsProvider | null;
    setPolicy(policy: SandboxPolicy): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    waitForReady(): Promise<void>;
    /**
     * Execute a command in the sandbox.
     *
     * Returns an ExecProcess which can be:
     * - awaited for a buffered result with strings
     * - iterated for streaming output
     * - used with stdin via write()/end()
     *
     * @example
     * ```typescript
     * // Simple command - await for result
     * const result = await vm.exec(['echo', 'hello']);
     * console.log(result.stdout); // 'hello\n'
     *
     * // Streaming output
     * for await (const line of vm.exec(['tail', '-f', '/var/log/syslog'])) {
     *   console.log(line);
     * }
     *
     * // Interactive with stdin
     * const proc = vm.exec(['cat'], { stdin: true });
     * proc.write('hello\n');
     * proc.end();
     * const result = await proc;
     * ```
     */
    exec(command: ExecInput, options?: ExecOptions): ExecProcess;
    /**
     * Start an interactive shell session.
     *
     * By default, attaches to process.stdin/stdout/stderr when running in a TTY.
     *
     * @example
     * ```typescript
     * // Simple interactive shell
     * const result = await vm.shell();
     * process.exit(result.exitCode);
     *
     * // Custom command
     * const result = await vm.shell({ command: 'python3' });
     *
     * // Manual control
     * const proc = vm.shell({ attach: false });
     * proc.write('ls\n');
     * for await (const chunk of proc) {
     *   process.stdout.write(chunk);
     * }
     * ```
     */
    shell(options?: ShellOptions): ExecProcess;
    private execInternal;
    private startExec;
    private startInternal;
    private stopInternal;
    private allocateId;
    private pipeStdin;
    private markSessionReady;
    private sendStdinData;
    private sendStdinEof;
    private sendStdinDataNow;
    private sendStdinEofNow;
    private sendPtyResize;
    private sendPtyResizeNow;
    private ensureConnection;
    private resetConnectionState;
    private initStatusPromise;
    private flushPolicy;
    private ensureBoot;
    private ensureRunning;
    private ensureVfsReady;
    private waitForVfsReadyInternal;
    private waitForMount;
    private execInternalNoVfsWait;
    private waitForStatus;
    private waitForState;
    private handleMessage;
    private updateState;
    private handleExecResponse;
    private handleError;
    private rejectAll;
    private handleDisconnect;
    private disconnect;
    private sendJson;
}
//# sourceMappingURL=vm.d.ts.map