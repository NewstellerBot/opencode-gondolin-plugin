"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpHooks = createHttpHooks;
const crypto_1 = __importDefault(require("crypto"));
const net_1 = __importDefault(require("net"));
const qemu_net_1 = require("./qemu-net");
function createHttpHooks(options = {}) {
    const env = {};
    const secretEntries = [];
    const blockInternalRanges = options.blockInternalRanges ?? true;
    for (const [name, secret] of Object.entries(options.secrets ?? {})) {
        const placeholder = `GONDOLIN_SECRET_${crypto_1.default.randomBytes(24).toString("hex")}`;
        env[name] = placeholder;
        secretEntries.push({
            name,
            placeholder,
            value: secret.value,
            hosts: secret.hosts.map(normalizeHostnamePattern),
        });
    }
    const allowedHosts = uniqueHosts([
        ...(options.allowedHosts ?? []),
        ...secretEntries.flatMap((entry) => entry.hosts),
    ]);
    const httpHooks = {
        isAllowed: async (info) => {
            if (blockInternalRanges && isInternalAddress(info.ip)) {
                return false;
            }
            // We only use the hostname for allowlist checks. The fetcher still uses
            // the hostname (not the resolved IP), so DNS rebinding does not let the
            // request target a different host. If you want to pin to resolved IPs,
            // supply a custom isAllowed hook.
            if (allowedHosts.length > 0 && !matchesAnyHost(info.hostname, allowedHosts)) {
                return false;
            }
            if (options.isAllowed) {
                return options.isAllowed(info);
            }
            return true;
        },
        onRequest: async (request) => {
            const hostname = getHostname(request);
            const headers = replaceSecretPlaceholders(request, hostname, secretEntries);
            let nextRequest = { ...request, headers };
            if (options.onRequest) {
                const updated = await options.onRequest(nextRequest);
                if (updated)
                    nextRequest = updated;
            }
            return nextRequest;
        },
        onResponse: options.onResponse,
    };
    return { httpHooks, env, allowedHosts };
}
function getHostname(request) {
    try {
        return new URL(request.url).hostname.toLowerCase();
    }
    catch {
        return "";
    }
}
function replaceSecretPlaceholders(request, hostname, entries) {
    if (entries.length === 0)
        return request.headers;
    const headers = { ...request.headers };
    for (const [headerName, value] of Object.entries(headers)) {
        let updated = value;
        for (const entry of entries) {
            if (!updated.includes(entry.placeholder))
                continue;
            if (!matchesAnyHost(hostname, entry.hosts)) {
                throw new qemu_net_1.HttpRequestBlockedError(`secret ${entry.name} not allowed for host: ${hostname || "unknown"}`);
            }
            updated = replaceAll(updated, entry.placeholder, entry.value);
        }
        headers[headerName] = updated;
    }
    return headers;
}
function matchesAnyHost(hostname, patterns) {
    const normalized = hostname.toLowerCase();
    return patterns.some((pattern) => matchHostname(normalized, pattern));
}
function normalizeHostnamePattern(pattern) {
    return pattern.trim().toLowerCase();
}
function matchHostname(hostname, pattern) {
    if (!pattern)
        return false;
    if (pattern === "*")
        return true;
    const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(`^${escaped.replace(/\\\*/g, ".*")}$`, "i");
    return regex.test(hostname);
}
function isInternalAddress(ip) {
    const family = net_1.default.isIP(ip);
    if (family === 4)
        return isPrivateIPv4(ip);
    if (family === 6)
        return isPrivateIPv6(ip);
    return false;
}
function isPrivateIPv4(ip) {
    const octets = ip.split(".").map((part) => Number(part));
    if (octets.length !== 4 || octets.some((part) => !Number.isInteger(part))) {
        return false;
    }
    const [a, b] = octets;
    if (a === 0)
        return true;
    if (a === 10)
        return true;
    if (a === 127)
        return true;
    if (a === 169 && b === 254)
        return true;
    if (a === 172 && b >= 16 && b <= 31)
        return true;
    if (a === 192 && b === 168)
        return true;
    if (a === 100 && b >= 64 && b <= 127)
        return true;
    if (a === 255)
        return true;
    return false;
}
function isPrivateIPv6(ip) {
    const hextets = parseIPv6Hextets(ip);
    if (!hextets)
        return false;
    const isAllZero = hextets.every((value) => value === 0);
    const isLoopback = hextets.slice(0, 7).every((value) => value === 0) && hextets[7] === 1;
    if (isAllZero || isLoopback)
        return true;
    if ((hextets[0] & 0xfe00) === 0xfc00)
        return true;
    if ((hextets[0] & 0xffc0) === 0xfe80)
        return true;
    const mapped = extractIPv4Mapped(hextets);
    if (mapped && isPrivateIPv4(mapped))
        return true;
    return false;
}
function parseIPv6Hextets(ip) {
    const normalized = ip.toLowerCase();
    const splitIndex = normalized.indexOf("::");
    if (splitIndex !== -1) {
        const leftPart = normalized.slice(0, splitIndex);
        const rightPart = normalized.slice(splitIndex + 2);
        const left = leftPart ? leftPart.split(":") : [];
        const right = rightPart ? rightPart.split(":") : [];
        const leftExpanded = expandIpv6Parts(left);
        const rightExpanded = expandIpv6Parts(right);
        if (!leftExpanded || !rightExpanded)
            return null;
        const missing = 8 - (leftExpanded.length + rightExpanded.length);
        if (missing < 0)
            return null;
        return [...leftExpanded, ...Array(missing).fill(0), ...rightExpanded];
    }
    const parts = normalized.split(":");
    const expanded = expandIpv6Parts(parts);
    if (!expanded || expanded.length !== 8)
        return null;
    return expanded;
}
function expandIpv6Parts(parts) {
    const expanded = [];
    for (const part of parts) {
        if (part.includes(".")) {
            const ipv4 = parseIPv4ToHextets(part);
            if (!ipv4)
                return null;
            expanded.push(...ipv4);
            continue;
        }
        if (part.length === 0)
            continue;
        const value = parseInt(part, 16);
        if (!Number.isFinite(value) || value < 0 || value > 0xffff)
            return null;
        expanded.push(value);
    }
    return expanded;
}
function parseIPv4ToHextets(ip) {
    const octets = ip.split(".").map((part) => Number(part));
    if (octets.length !== 4 || octets.some((part) => !Number.isInteger(part))) {
        return null;
    }
    const [a, b, c, d] = octets;
    if ([a, b, c, d].some((part) => part < 0 || part > 255))
        return null;
    return [(a << 8) | b, (c << 8) | d];
}
function extractIPv4Mapped(hextets) {
    if (hextets.length !== 8)
        return null;
    const prefixZero = hextets.slice(0, 5).every((value) => value === 0);
    if (!prefixZero || hextets[5] !== 0xffff)
        return null;
    const a = hextets[6] >> 8;
    const b = hextets[6] & 0xff;
    const c = hextets[7] >> 8;
    const d = hextets[7] & 0xff;
    return `${a}.${b}.${c}.${d}`;
}
function uniqueHosts(hosts) {
    const seen = new Set();
    const result = [];
    for (const host of hosts) {
        const normalized = normalizeHostnamePattern(host);
        if (!normalized || seen.has(normalized))
            continue;
        seen.add(normalized);
        result.push(normalized);
    }
    return result;
}
function replaceAll(value, search, replacement) {
    if (!search)
        return value;
    return value.split(search).join(replacement);
}
//# sourceMappingURL=http-hooks.js.map