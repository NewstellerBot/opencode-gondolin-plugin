"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const vm_1 = require("../src/vm");
const MAX_STDIN_BYTES = 16 * 1024 * 1024;
function resolveRepoRoot() {
    return path_1.default.resolve(__dirname, "../..");
}
function defaultTestPaths(repoRoot) {
    return [
        {
            label: "module",
            hostPath: path_1.default.resolve(repoRoot, "guest/zig-out/bin/sandboxd-mod-tests"),
        },
        {
            label: "executable",
            hostPath: path_1.default.resolve(repoRoot, "guest/zig-out/bin/sandboxd-exe-tests"),
        },
    ];
}
async function runTest(vm, label, payload) {
    const guestPath = `/tmp/sandboxd-${label}-tests`;
    const command = [
        "/bin/sh",
        "-c",
        `cat > ${guestPath} && chmod +x ${guestPath} && ${guestPath}`,
    ];
    const proc = vm.exec(command, { stdin: payload });
    // Stream output as it arrives
    for await (const chunk of proc.output()) {
        if (chunk.stream === "stdout") {
            process.stdout.write(chunk.data);
        }
        else {
            process.stderr.write(chunk.data);
        }
    }
    const result = await proc;
    if (result.exitCode !== 0) {
        throw new Error(`guest ${label} tests failed with exit code ${result.exitCode}`);
    }
}
async function main() {
    const repoRoot = resolveRepoRoot();
    const tests = defaultTestPaths(repoRoot);
    for (const test of tests) {
        if (!fs_1.default.existsSync(test.hostPath)) {
            throw new Error(`missing test binary: ${test.hostPath}`);
        }
    }
    const vm = new vm_1.VM({
        server: {
            console: "none",
            maxStdinBytes: MAX_STDIN_BYTES,
        },
    });
    try {
        await vm.start();
        for (const test of tests) {
            const payload = fs_1.default.readFileSync(test.hostPath);
            await runTest(vm, test.label, payload);
        }
    }
    finally {
        await vm.stop();
    }
}
main().catch((err) => {
    const message = err instanceof Error ? err.message : String(err);
    process.stderr.write(`${message}\n`);
    process.exit(1);
});
//# sourceMappingURL=guest-tests.js.map