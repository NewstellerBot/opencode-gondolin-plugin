"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const vm_1 = require("../src/vm");
const http_hooks_1 = require("../src/http-hooks");
const vfs_1 = require("../src/vfs");
const errors_1 = require("../src/vfs/errors");
const WS_URL = process.env.WS_URL;
const TOKEN = process.env.ELWING_TOKEN ?? process.env.SANDBOX_WS_TOKEN;
const ALLOWED_HOSTS = ["registry.npmjs.org", "pypi.org", "files.pythonhosted.org"];
const { errno: ERRNO } = os_1.default.constants;
const VirtualProviderClass = vfs_1.VirtualProvider;
class MagicGitProvider extends VirtualProviderClass {
    constructor() {
        super(...arguments);
        this.cloneRoot = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), "magic-git-"));
        this.owners = new Map();
        this.repos = new Map();
    }
    get readonly() {
        return true;
    }
    get supportsSymlinks() {
        return true;
    }
    get supportsWatch() {
        return false;
    }
    async open(entryPath, flags, mode) {
        return this.openSync(entryPath, flags, mode);
    }
    openSync(entryPath, flags, mode) {
        if (isWriteFlag(flags)) {
            throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "open", entryPath);
        }
        const resolved = this.resolve(entryPath);
        if (resolved.kind !== "repo" || isRepoRoot(resolved)) {
            throw (0, errors_1.createErrnoError)(ERRNO.EISDIR, "open", entryPath);
        }
        return this.getRepoProvider(resolved).openSync(resolved.relativePath, flags, mode);
    }
    async stat(entryPath, options) {
        return this.statSync(entryPath, options);
    }
    statSync(entryPath, options) {
        const resolved = this.resolve(entryPath);
        if (resolved.kind === "repo") {
            if (isRepoRoot(resolved)) {
                return createVirtualDirStats();
            }
            return this.getRepoProvider(resolved).statSync(resolved.relativePath, options);
        }
        if (resolved.kind === "owner") {
            this.listRepos(resolved.owner, "stat", entryPath);
        }
        return createVirtualDirStats();
    }
    async lstat(entryPath, options) {
        return this.lstatSync(entryPath, options);
    }
    lstatSync(entryPath, options) {
        const resolved = this.resolve(entryPath);
        if (resolved.kind === "repo") {
            if (isRepoRoot(resolved)) {
                return createVirtualDirStats();
            }
            return this.getRepoProvider(resolved).lstatSync(resolved.relativePath, options);
        }
        if (resolved.kind === "owner") {
            this.listRepos(resolved.owner, "lstat", entryPath);
        }
        return createVirtualDirStats();
    }
    async readdir(entryPath, options) {
        return this.readdirSync(entryPath, options);
    }
    readdirSync(entryPath, options) {
        const resolved = this.resolve(entryPath);
        const withTypes = Boolean(options?.withFileTypes);
        if (resolved.kind === "repo") {
            return this.getRepoProvider(resolved).readdirSync(resolved.relativePath, options);
        }
        if (resolved.kind === "owner") {
            const repos = this.listRepos(resolved.owner, "readdir", entryPath);
            return formatEntries(repos, withTypes);
        }
        const owners = Array.from(this.owners.keys()).sort();
        return formatEntries(owners, withTypes);
    }
    async mkdir(entryPath, _options) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "mkdir", entryPath);
    }
    mkdirSync(entryPath, _options) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "mkdir", entryPath);
    }
    async rmdir(entryPath) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "rmdir", entryPath);
    }
    rmdirSync(entryPath) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "rmdir", entryPath);
    }
    async unlink(entryPath) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "unlink", entryPath);
    }
    unlinkSync(entryPath) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "unlink", entryPath);
    }
    async rename(oldPath, _newPath) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "rename", oldPath);
    }
    renameSync(oldPath, _newPath) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "rename", oldPath);
    }
    async readlink(entryPath, options) {
        return this.readlinkSync(entryPath, options);
    }
    readlinkSync(entryPath, options) {
        const resolved = this.resolve(entryPath);
        if (resolved.kind === "repo") {
            if (isRepoRoot(resolved)) {
                throw (0, errors_1.createErrnoError)(ERRNO.EINVAL, "readlink", entryPath);
            }
            const provider = this.getRepoProvider(resolved);
            if (provider.readlinkSync) {
                return provider.readlinkSync(resolved.relativePath, options);
            }
            throw (0, errors_1.createErrnoError)(ERRNO.EINVAL, "readlink", entryPath);
        }
        throw (0, errors_1.createErrnoError)(ERRNO.EINVAL, "readlink", entryPath);
    }
    async symlink(_target, entryPath, _type) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "symlink", entryPath);
    }
    symlinkSync(_target, entryPath, _type) {
        throw (0, errors_1.createErrnoError)(ERRNO.EROFS, "symlink", entryPath);
    }
    async realpath(entryPath, options) {
        return this.realpathSync(entryPath, options);
    }
    realpathSync(entryPath, options) {
        const resolved = this.resolve(entryPath);
        if (resolved.kind === "repo") {
            if (isRepoRoot(resolved)) {
                return normalizePath(entryPath);
            }
            const provider = this.getRepoProvider(resolved);
            if (provider.realpathSync) {
                return provider.realpathSync(resolved.relativePath, options);
            }
            return normalizePath(entryPath);
        }
        return normalizePath(entryPath);
    }
    async access(entryPath, mode) {
        return this.accessSync(entryPath, mode);
    }
    accessSync(entryPath, mode) {
        const resolved = this.resolve(entryPath);
        if (resolved.kind === "repo") {
            if (isRepoRoot(resolved)) {
                return;
            }
            const provider = this.getRepoProvider(resolved);
            if (provider.accessSync) {
                return provider.accessSync(resolved.relativePath, mode);
            }
            return;
        }
        if (resolved.kind === "owner") {
            this.listRepos(resolved.owner, "access", entryPath);
        }
    }
    async close() {
        fs_1.default.rmSync(this.cloneRoot, { recursive: true, force: true });
    }
    resolve(entryPath) {
        const normalized = normalizePath(entryPath);
        const parts = normalized.split("/").filter(Boolean);
        if (parts.length === 0)
            return { kind: "root" };
        if (parts.length === 1)
            return { kind: "owner", owner: parts[0] };
        const [owner, repo, ...rest] = parts;
        const relativePath = rest.length === 0 ? "/" : `/${rest.join("/")}`;
        return { kind: "repo", owner, repo, relativePath };
    }
    listRepos(owner, op, entryPath) {
        const cached = this.owners.get(owner);
        if (cached)
            return cached;
        try {
            const output = (0, child_process_1.execFileSync)("gh", ["repo", "list", owner, "--limit", "1000", "--json", "name"], { encoding: "utf8" });
            const repos = JSON.parse(output).map((repo) => repo.name);
            this.owners.set(owner, repos);
            return repos;
        }
        catch {
            throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, op, entryPath);
        }
    }
    getRepoProvider(resolved) {
        const key = `${resolved.owner}/${resolved.repo}`;
        const cached = this.repos.get(key);
        if (cached)
            return cached;
        const repos = this.listRepos(resolved.owner, "stat", `/${resolved.owner}`);
        if (!repos.includes(resolved.repo)) {
            throw (0, errors_1.createErrnoError)(ERRNO.ENOENT, "stat", `/${key}`);
        }
        const repoPath = path_1.default.join(this.cloneRoot, resolved.owner, resolved.repo);
        if (!fs_1.default.existsSync(repoPath)) {
            fs_1.default.mkdirSync(path_1.default.dirname(repoPath), { recursive: true });
            (0, child_process_1.execFileSync)("gh", ["repo", "clone", key, repoPath], { stdio: "inherit" });
        }
        const provider = new vfs_1.ReadonlyProvider(new vfs_1.RealFSProvider(repoPath));
        this.repos.set(key, provider);
        return provider;
    }
}
class VirtualDirent {
    constructor(name) {
        this.name = name;
    }
    isFile() {
        return false;
    }
    isDirectory() {
        return true;
    }
    isSymbolicLink() {
        return false;
    }
    isBlockDevice() {
        return false;
    }
    isCharacterDevice() {
        return false;
    }
    isFIFO() {
        return false;
    }
    isSocket() {
        return false;
    }
}
function createVirtualDirStats() {
    const now = Date.now();
    const stats = Object.create(fs_1.default.Stats.prototype);
    Object.assign(stats, {
        dev: 0,
        mode: 0o040755,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        ino: 0,
        size: 4096,
        blocks: 8,
        atimeMs: now,
        mtimeMs: now,
        ctimeMs: now,
        birthtimeMs: now,
        atime: new Date(now),
        mtime: new Date(now),
        ctime: new Date(now),
        birthtime: new Date(now),
    });
    return stats;
}
function formatEntries(entries, withTypes) {
    if (!withTypes)
        return entries;
    return entries.map((entry) => new VirtualDirent(entry));
}
function normalizePath(inputPath) {
    let normalized = path_1.default.posix.normalize(inputPath);
    if (!normalized.startsWith("/")) {
        normalized = `/${normalized}`;
    }
    if (normalized.length > 1 && normalized.endsWith("/")) {
        normalized = normalized.slice(0, -1);
    }
    return normalized;
}
function isRepoRoot(resolved) {
    return resolved.relativePath === "/";
}
function isWriteFlag(flags) {
    return /[wa+]/.test(flags);
}
async function main() {
    if (process.argv.includes("--help") || process.argv.includes("-h")) {
        console.log("Usage: magic-git-bash");
        console.log();
        console.log("Starts a bash shell with /git mounted and npm/pypi network access.");
        process.exit(0);
    }
    const { httpHooks } = (0, http_hooks_1.createHttpHooks)({ allowedHosts: ALLOWED_HOSTS });
    const vm = new vm_1.VM({
        url: WS_URL ?? undefined,
        token: TOKEN ?? undefined,
        httpHooks,
        vfs: { mounts: { "/git": new MagicGitProvider() } },
    });
    try {
        const result = await vm.shell();
        if (result.signal !== undefined) {
            process.stderr.write(`process exited due to signal ${result.signal}\n`);
        }
        await vm.stop();
        process.exit(result.exitCode);
    }
    catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        process.stderr.write(`${message}\n`);
        await vm.stop();
        process.exit(1);
    }
}
main().catch((err) => {
    const message = err instanceof Error ? err.message : String(err);
    process.stderr.write(`${message}\n`);
    process.exit(1);
});
//# sourceMappingURL=magic-git-bash.js.map